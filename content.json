[{"title":"iOS多线程编程 GCD介绍","date":"2017-05-19T06:52:46.000Z","path":"2017/05/19/GCDInfo/","text":"作者刘文涛转载请注明出处 一、简单介绍1.什么是GCDGrand Central Dispatch是由苹果开发的一个多核编程的解决方案。iOS4.0+才能使用，是替代NSThread， NSOperation的高效和强大的技术。苹果官方给出的解释：GCD是异步执行任务的技术之一。一般将应用程序中记述的线程管理代码在系统集中实现，开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就可以生成必要的线程并计划执行任务。GCD是基于C语言的。 2.GCD的优点它具有以下优点：1.GCD可以将花费时间及其长的任务放到后台线程，可以改善应用的响应性能。2.GCD提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。3.GCD具有在常见模式（例如单例）上用更高性能的底层语法优化你的代码的潜在能力等等。我创建一个并行队列queue，并异步执行耗时操作，当耗时操作执行完成后，我拿到其中的资源回到主线程来更新相应的UI，在这个block代码块之外，主线程并不会被耗时任务所堵塞，可以流畅的处理其他的事情。代码片段如下： 1234567891011121314151617dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); //用异步的方法执行任务 dispatch_async(queue, ^&#123; /** 放一些耗时的任务在此执行 */ dispatch_async(dispatch_get_main_queue(), ^&#123; /** 耗时的任务完成，拿到资源，回到主线程，更新UI 注意：更新UI只能在主线程中 */ &#125;); &#125;); 二、任务和队列GCD有两个核心的概念：1.任务：执行什么操作2.队列：用来存放任务GCD的使用步骤：1.定制任务2.确定想做的事情 将任务添加到队列中，GCD会自动将队列中的任务取出，放到相应的线程中去执行。提示：任务的取出遵循队列的FIFO（first in,first out）原则：先进先出，后进后出。 三、执行任务1.GCD中有2个用来执行任务的函数 说明：把右边的参数（任务）提交给左边的参数（队列）进行执行。 （1）用同步的方法执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 参数说明： queue：队列 block：任务 （2）用异步的方法执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 2.同步和异步的区别 同步：在当前线程中执行 异步：在另一条线程中执行 四、队列1.队列的类型GCD的队列可以分为2大类（1）并发队列 （ DISPATCH_QUEUE_CONCURRENT ） 可以让多个任务并发执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch——async）函数下才有效（2）串行队列 （ DISPATCH_QUEUE_SERIAL ） 让任务一个接一个的执行 （一个任务执行完毕后，在执行下一个任务） 2.补充说明同步和异步决定了要不要开启新的线程。同步：在当前线程中执行任务，不具备开启新线程的能力异步：在新的线程中执行任务，具备开启新线程的能力 并发和串行决定了任务的执行方式并发：多个任务同时执行串行：一个任务执行完毕后，在执行下一个任务 3.串行队列GCD中获得串行有两种途径（1）使用dispatch_queue_create函数创建串行队列 1dispatch_queue_t queue = dispatch_queue_create(&lt;#const char * _Nullable label#&gt;, &lt;#dispatch_queue_attr_t _Nullable attr#&gt;) //// 队列名称， 队列属性，一般用NULL即可 示例：1dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", NULL); （2）使用主队列主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务都会放到主线程中执行 使用dispatch_get_main_queue()获得主队列示例： 1dispatch_queue_t queue2 = dispatch_get_main_queue(); 4.并发队列GCD默认已经提供全局的并发队列，供整个应用使用，不需要手动创建使用dispatch_get_global_queue函数获得全局的并发队列示例： 1234567dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);说明：全局并发队列的优先级 #define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高 #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中） #define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低 #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台 5.各队列的执行效果 全局并发队列 手动创建串行队列 主队列 同步（sync） 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 异步（async) 开启新线程，并发执行任务 开启新线程，串行执行任务 没有开启新线程，串行执行任务 五、示例代码1.用异步函数往并发队列中添加任务示例： 1234567891011121314151617181920//1.获得全局的并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //2.添加任务到队列中，就可以执行任务 //异步函数：具备开启新线程的能力 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"主线程----%@\",[NSThread mainThread]); 输出：结论：在并发队列+异步执行中可以看出，除了主线程同时又开启了三个子线程，并且任务交替着同时执行。并且任务不是马上执行的，而是将所有的任务添加到队列之后才开始异步执行的。 2.用异步函数往串行队列中添加任务示例： 123456789101112131415161718192021222324252627//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1、创建串行队列 /** 第一个参数为串行队列的名称，是c语言的字符串 第二个参数为队列的属性，一般来说串行队列不需要赋值任何属性，所以通常传空值（NULL） */ dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", NULL); //2、添加任务到队列中执行 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：在串行队列+异步执行可以看到，只开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。并且是将所有任务添加到队列之后才开始同步执行。 3.用同步函数往并发队列中添加任务示例： 1234567891011121314151617181920212223//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：所有的任务都是在主线程中执行的，由于只有一个线程，所以任务只能一个一个执行，执行完一个任务，再执行下一个任务。并且并发队列是去了并发的功能。并且任务是添加到队列中马上执行的。 4.用同步函数往串行队列中添加任务示例： 1234567891011121314151617181920212223//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_SERIAL); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：所有的任务都是在主线程中执行的，并没有开启新的线程，并且按顺序一个一个执行。并且任务是添加到队列中马上执行的。 5.同步函数在主队列中执行示例： 12345678910111213141516171819202122232425- (void)syncMain&#123; //打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //获取主线程 dispatch_queue_t queue = dispatch_get_main_queue(); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;);&#125; 输出：这时候，我们发现在主线程中使用主队列+同步执行，任务不再执行了，这是为什么呢？这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主线程中他会立马执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个任务和第三个任务。那么现在的情况就是syncMain方法和第一的任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，我们的任务执行不了了。 不在主线程中调用，而在其他线程中调用1234dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [self syncMain]; &#125;); 123456789101112131415161718192021222324252627- (void)syncMain&#123; NSLog(@\"syncMain---begin\"); //打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //获取主线程 dispatch_queue_t queue = dispatch_get_main_queue(); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"syncMain---begin\");&#125; 输出：结论：所有的任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个的执行。同时我们还可以看到，所有的任务都是打印在syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。 6.异步函数在主队列中执行示例： 123456789101112131415161718192021222324- (void)asyncMain&#123; NSLog(@\"asyncMain---begin\"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"asyncMain---end\");&#125; 输出：结论：所有的任务都是在主线程中，虽然是异步执行，具备开启线程的能力，但是因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。 6.GCD的其他方法1.GCD的栅栏方法我们有时候需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。 123456789101112131415161718192021222324252627- (void)barrier&#123; dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@\"barrier-----%@\",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"4------%@\",[NSThread currentThread]); &#125; &#125;);&#125; 输出：结论：可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后在执行栅栏后面的操作。 2.GCD的延时执行方法当我们需要延时执行一段代码时，就需要用到GCD的dispatch_after方法示例： 1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.9 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //2 秒后执行这里的代码 NSLog(@\"run-----\"); &#125;); 3.GCD只执行一次我们在创建单例或者整个程序运行过程中只执行一次的代码时，我们就用到了GCD的dispatch_once方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。示例： 1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //只执行1次的代码（这里面默认是线程安全的） &#125;); 4.GCD的快速迭代方法通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法dispatch_apply，使我们可以同时遍历。比如遍历0~5这6个数字，for循环是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。示例： 12345dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_apply(6, queue, ^(size_t index) &#123; NSLog(@\"%zd--------%@\",index,[NSThread currentThread]); &#125;); 输出：结论：从输出结果的时间可以看出，几乎是同时遍历出的。 5.GCD的队列组有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后在回到主线程执行操作。这时候我们可以用到GCD的队列组。我们可以先把任务放到队列中，然后将队列放入队列组中。调用队列组的dispatch_group_notify回到主线程执行操作。示例： 123456789101112//创建一个队列组 dispatch_group_t group = dispatch_group_create(); //添加任务到队列组中 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行1个耗时的异步操作 &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行1个耗时的异步操作 &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //等前面的异步操作都执行完毕后，回到主线程中... &#125;); 结语以上就是我对GCD的基础知识和几种组合的理解，如果觉得我有哪里理解的错误欢迎留下你的评论。","tags":[{"name":"多线程 GCD","slug":"多线程-GCD","permalink":"http://yoursite.com/tags/多线程-GCD/"}]},{"title":"iOS多线程编程 NSOperation","date":"2017-05-11T02:28:31.000Z","path":"2017/05/11/NSOperation/","text":"作者刘文涛转载请注明出处 一、NSOperation1、简介NSOperation实例封装了需要执行的操作和执行操作所需的数据，并且能够以并发或非并发的方式执行这个操作。NSOperation本身是抽象基类，因此必须使用它的子类，使用NSOperation子类的方式有两种：1.Foundation框架提供了两个具体子类直接供我们使用：NSInvocationOperation和NSBlockOperation2.自定义子类继承NSOperation，实现内部相应的方法 2、执行操作NSOperation调用start方法即可开始执行操作，NSOperation对象默认按同步方式执行，也就是调用start方法的那个线程中直接执行。NSOperation对象的isConcurrent方法会告诉我们这个操作相对于调用start方法的线程，是同步还是异步执行。isConcurrent默认是返回NO,表示操作与调用线程同步执行 NSOperation * operation = [[NSOperation alloc]init]; //开始执行 [operation start]; 3、取消操作Operation开始执行之后，默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作 [operation cancel]; 4、监听操作的执行如果我们想在一个NSOperation执行完毕后做一些事，就调用NSOperation的setCompletionBlock方法： [operation setCompletionBlock:^{ NSLog(@&quot;执行结束&quot;); }]; 二、NSInvocationOperation1.简介基于一个对象和selector来创建操作。如果你已经有现有的方法来执行需要的任务，就可以使用这个类 2.创建并执行操作 //调用self的run方法 NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //开始执行任务（同步执行） [operation start]; 三、NSBlockOperation1.简介能够并发的执行一个或者多个block对象，所有相关的block都执行完之后，操作才算完成。 2.创建并执行操作NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@&quot;执行一个新的操作&quot;); }]; //开始执行任务（同步执行） [operation start]; 3.通过addExecutionBlock方法添加block操作NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@&quot;执行一个新的操作&quot;); }]; [operation addExecutionBlock:^{ NSLog(@&quot;添加1个新的操作&quot;); }]; //开始执行任务（同步执行） [operation start]; 这两个block是并发执行的，也就是在不同的线程中执行的 四、自定义NSOperation1.简介如果NSInvocationOperation和NSBlockOperation对象不能满足需求, 你可以直接继承NSOperation, 并添加任何你想要的行为。继承所需的工作量主要取决于你要实现非并发还是并发的NSOperation。定义非并发的NSOperation要简单许多，只需要重载- (void)main这个方法，在这个方法里面执行主任务，并正确的响应取消事件；对于并发的NSOperation，你必须重新NSOperation的多个基本方法进行实例","tags":[{"name":"多线程 NSOperation","slug":"多线程-NSOperation","permalink":"http://yoursite.com/tags/多线程-NSOperation/"}]},{"title":"iOS多线程编程 NSThread介绍","date":"2017-05-10T01:35:33.000Z","path":"2017/05/10/NSThread/","text":"作者刘文涛转载请注明出处 一、简单介绍iOS支持多个层次的多线程编程，层次越高的抽象程度越高，使用也越方便，也是苹果最推荐的使用方法。下面根据抽象层次从低到高依次列出iOS所支持的多线程编程方法：1.Thread：是三种方法里相对轻量级的，但是需要管理线程的生命周期、同步、加锁问题，这会导致一定的性能开销；2.Cocoa Operations：是基于OC实现的，NSOperation以面向对象的方式封装了需要执行的操作，不必关心线程管理、同步等问题。NSOperation是一个抽象基类，iOS提供了两种默认实现：NSInvocationOperation和NSBlockOperation，当然也可以自定义NSOperation；3.Grand Central Dispatch（简称GCD，iOS4才开始支持的）：提供了一些新特性、运行库来支持多核并行编程，它的关注点更高：如何在多个CPU上提升效率； 这篇文章简单的介绍了第一种多线程的编程方式，主要利用NSThread这个类，一个NSThread实例代表着一条多线程。 二、NSthread的初始化1.动态方法- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0); 参数解析： target：selector消息发送的对象 selector：线程执行的方法，这个selector最多只能接收一个参数 argument：传给selector的唯一参数，也可以是nil 123456//初始化线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; //设置线程的优先级（0.0 -- 1.0 ,1.0是最高级） thread.threadPriority = 1.0; //开启线程 [thread start]; 2.静态方法+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 12[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];//调用完毕后，会马上创建并开启新的线程 3.隐式创建线程的方法[self performSelectorInBackground:@selector(run) withObject:nil]; 三、获取当前线程NSThread *current = [NSThread currentThread]; 四、获取主线程NSThread *mainThread = [NSThread mainThread]; 五、暂停当前线程//暂停2.0s [NSThread sleepForTimeInterval:2.0]; //或者 NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]]; [NSThread sleepUntilDate:date]; 六、线程间的通信1.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 2.在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 3.在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 七、优缺点优点：NSTread比其他两种多线程方案较轻量级，更直观的控制线程对象缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据加锁或有一定的系统开销。","tags":[{"name":"多线程 NSThread","slug":"多线程-NSThread","permalink":"http://yoursite.com/tags/多线程-NSThread/"}]},{"title":"iOS开发masonry动态布局cell高度","date":"2017-04-15T07:39:36.000Z","path":"2017/04/15/masonryForCell/","text":"作者刘文涛转载请注明出处 前言说到iOS自动布局，有很多的解决办法。有的人使用xib/storyboard自动布局，也有人使用frame来适配。对于前者，笔者并不喜欢，也不支持。对于后者，更是麻烦，到处计算高度、宽度等，千万大量代码的冗余，对维护和开发的效率都很低。笔者在这里介绍纯代码自动布局的第三方库：Masonry。这个库使用率相当高，在全世界都有大量的开发者在使用，其star数量也是相当高的。本文Cell内容通过Masonry自动布局并且cell巧妙利用自动布局计算cell的动态高度。 正文实现思路：例如cell中有三个label，label1，label2，label3.1.为label1添加约束（以cell.cntentView为基准） 123456CGFloat one_W = SCREENWIDTH/2;[self.L1 makeConstraints:^*(MASConstraintMaker *make)&#123; make.left.mas_equalTo(16); make.top.mas_equalTo (10); make.width.mas_lessThanOrEqualTo(one_W);&#125;]; 2.为label2添加约束 使其在label1下方距离为5处 （以label1为基准）。 12345[self.L2makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(wself.L1.mas_left); make.top.equalTo(wself.L1.mas_bottom).offset(5); make.width.mas_lessThanOrEqualTo(one_W);&#125;]; 3.为label3添加约束 使其在label2 下方距离为5处 （以label2为基准，重点在于这个一定要在label3 添加一个距离cell。contentView底部的约束）。以上完成cell 子视图的约束。 123456[self.L3 makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(wself.L1.mas_left); make.top.equalTo(wself.L2.mas_bottom).offset(5); make.width.mas_lessThanOrEqualTo(SCREENWIDTH-32);make.bottom.equalTo(wself.contentView.mas_bottom).offset(-10);&#125;]; 4.在tableView heightForRowAtIndexPath 代理中使用一个单独的不显示在屏幕的cell 作为计算cell高度使用，通过下面代码获取cell高度： 1234567891011customCell *cell= [customCellshareInstance]; //返回cell之前重新刷新约束，重新计算高度 [cell setNeedsUpdateConstraints]; [cell updateConstraintsIfNeeded]; [cell setCellContent:self.data[indexPath.row]]; [cell setNeedsLayout]; [cell layoutIfNeeded]; CGFloat height = [cell.contentViewsystemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; return height; 本文demo","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"masonry","slug":"masonry","permalink":"http://yoursite.com/tags/masonry/"},{"name":"动态布局","slug":"动态布局","permalink":"http://yoursite.com/tags/动态布局/"}]},{"title":"如何使UIWebview/WKWebView支持WebP格式图片","date":"2017-04-13T05:43:26.000Z","path":"2017/04/13/webp-image-format-ios/","text":"作者Talent•C转载自Talent•C 前言在一般的app中占用流量最大的内容一般都是图片,以苹果公司 Retina 产品为代表的高 PPI 屏对图片的质量提出了更高的要求，如何保证在图片的精细度不降低的前提下缩小图片体积，成为了一个有价值且值得探索的事情。但如今对于 JPEG、PNG 和 GIF 这些图片格式的优化几乎已经达到了极致， 若想改变现状开辟新局面，便要有釜底抽薪的胆量和气魄，而 Google 给了我们一个新选择：WebP。 正文WebP是什么? WebP（发音 weppy，来自:Google WebP），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。在 Google 的明星产品如 Youtube、Gmail、Google Play 中都可以看到 WebP 的身影，而 Chrome 网上商店甚至已完全使用了 WebP。国外公司如 Facebook、ebay 和国内公司如腾讯、淘宝、美团等也早已尝鲜。下面是QQ图片格式对比图 iOS中如何使用WebP格式图片?很幸运,SDWebImage支持WebP格式图片,可以讲WebP数据–&gt;NSData–&gt;UIImage There are 3 subspecs available now: Core, MapKit and WebP (this means you can install only some of the SDWebImage modules. By default, you get just Core, so if you need WebP, you need to specify it).Podfile example:$pod ‘SDWebImage/WebP’摘自SDWebImage 我们需要手动下载WebP这个库,由于是从Google下载的,如果下载失败,请翻墙重试!!!下载后的文件路径 Xcode 需要如下配置 targets-&gt;build settings -&gt;preprocessor Macros 填写 SD_WEBP=1 如图到此app 中支持 WebP图片基本完成,但是重点来了,由于部分app使用到了UIWebview/WKWebview 这两个控件是不支持WebP图片的,目前有两种方式可以让其支持WebP格式图片。 实现方式一 NSURLProtocol对于NSURLProtocol的作用及使用以后找个时间再讲了~~~~可以参考Apple 开发者文档NSURLProtocol, UIWebView 直接就可以支持,但是WKWebView是不支持的,如何让WKWebView也支持NSURLProtocol可以参考这篇文章,不过WKWebView自定义NSURLProtocol会丢失boay数据。文章结尾会附上Demo下载地址。 WKWebView 拓展支持NSURLProtocol 具体代码如下12345678910111213141516171819202122232425262728293031323334FOUNDATION_STATIC_INLINE Class ContextControllerClass() &#123; static Class cls; if (!cls) &#123; cls = [[[WKWebView new] valueForKey:@\"browsingContextController\"] class]; &#125; return cls;&#125;FOUNDATION_STATIC_INLINE SEL RegisterSchemeSelector() &#123; return NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");&#125;FOUNDATION_STATIC_INLINE SEL UnregisterSchemeSelector() &#123; return NSSelectorFromString(@\"unregisterSchemeForCustomProtocol:\");&#125;@implementation NSURLProtocol (WebKitExt)+ (void)wk_registerScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = RegisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125;+ (void)wk_unregisterScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = UnregisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125; 好了,现在UIWebView与WKWebView 都已经支持自定义NSURLProtocol了;我们创建一个类CLURLProtocol 继承自NSURLProtocol下面这几个方法必须实现 +(BOOL)canInitWithRequest:(NSURLRequest )request;+(NSURLRequest )canonicalRequestForRequest:(NSURLRequest *)request;-(void)stopLoading;-(void)startLoading; 这里不过多废话了 直接上代码123456789101112131415161718192021222324+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; /** 判断是否启用SD_WEBP 并且图片格式为webp 如果为YES 则标记请求需要自行处理并且防止无限循环 为NO则不处理 */ BOOL useCustomUrlProtocol = NO; NSString *urlString = request.URL.absoluteString; if (!SD_WEBP || ([urlString.pathExtension compare:@\"webp\"] != NSOrderedSame)) &#123; useCustomUrlProtocol = NO; &#125;else &#123; //防止无限循环 if ([NSURLProtocol propertyForKey:CLProtocolKey inRequest:request] == nil) &#123; useCustomUrlProtocol = YES; &#125;else &#123; useCustomUrlProtocol = NO; &#125; &#125; return useCustomUrlProtocol;&#125;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; return request;&#125;- (void)stopLoading&#123; //将截获的请求使用NSURLConnection | NSURLSession 获取数据 这里使用的是NSURLConnection&#125; 我们在创建一个WebV继承自UIViewController 用来展示webView12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; self.automaticallyAdjustsScrollViewInsets = NO; if ([self.webView isKindOfClass:[WKWebView class]]) &#123; //WKWebView 注册自定义 NSURLProtocol [NSURLProtocol registerClass:NSClassFromString(@\"CLURLProtocol\")]; [NSURLProtocol wk_registerScheme:@\"http\"]; [NSURLProtocol wk_registerScheme:@\"https\"]; //发起请求 WKWebView *web = (WKWebView *)self.webView; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://onzbjws3p.bkt.clouddn.com/testForwebpSrc/testWebpForHtml.html\"]]]; &#125;else if ([self.webView isKindOfClass:[UIWebView class]]) &#123; //UIWebView 注册自定义 NSURLProtocol [NSURLProtocol registerClass:NSClassFromString(@\"CLURLProtocol\")]; //发起请求 UIWebView *web = (UIWebView *)self.webView; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://onzbjws3p.bkt.clouddn.com/testForwebpSrc/testWebpForHtml.html\"]]]; &#125; &#125;//因为NSURLProtocol 一旦被注册将会使整个app的request请求都会被拦截 我们这里只在进入WebVC时向系统注册,退出WebVC时取消注册 具体时机请自行决定- (void)dealloc&#123; NSLog(@\"WebVC -- dealloc\"); if ([self.webView isKindOfClass:[WKWebView class]]) &#123; [NSURLProtocol unregisterClass:NSClassFromString(@\"CLURLProtocol\")]; [NSURLProtocol wk_unregisterScheme:@\"http\"]; [NSURLProtocol wk_unregisterScheme:@\"https\"]; &#125;else if ([self.webView isKindOfClass:[UIWebView class]]) &#123; [NSURLProtocol unregisterClass:NSClassFromString(@\"CLURLProtocol\")]; &#125;&#125; 到此为止UIWebView/WKWebView 均已支持加载webp格式图片效果如图WKWebView 展示效果 UIWebView 展示效果 UIImageView 展示效果 优点: 适合所有网页,可以不用修改网页内部html内容。 缺点: NSURLProtocol 拦截App 的所有请求, 使用时需要根据个人项目情况而定, WKWebView 在post请求时会丢失boay, 目前解决方式为在WKWebView的 开始加载的 代理方法判断是否为post,为post解除注册自定义的NSURLProtocol,为GET请求时注册自定义NSURLProtocol。 实现方式二 通过JavaScript与OC共同完成实现思路:1、向网页内注入JS2、在App 本地开启线程下载图片,下载完成后,将图片转码由 webP—&gt; png—&gt;Base64。3、将 Base64及原图片下载地址一一对应调用JS准备好的方法进行替换。4、将下载后的图片进行缓存,并进行管理。 注意注意:A、图片未真正加载完毕时,网页中图片为了体验好可以添加默认占位图片。B、图片显示成功前应该保持网页布局不调整,需要由JS预先设置好布局。C、图片在本地的缓存需要管理。 获取网页img标签的js代码123456789101112function talentcGetAllImageSrc ()&#123; var imagesList = document.images; var srcList = []; var patt1 = new RegExp(\"\\.webp$\"); for(var i = 0; i &lt; imagesList.length; i++) &#123; if(patt1.test(imagesList[i].src)) &#123; srcList.push(imagesList[i].src); &#125; &#125; return JSON.stringify(srcList);&#125;; 替换网页img标签的js代码1234567function talentcReplaceWebPImg (src, localPath)&#123; var elementList = document.querySelectorAll('img[src=\"'+src+'\"]'); for(var element in elementList) &#123; elementList[element].src = localPath; &#125;&#125; 优点:对于UIWebview 与 WKWebView是通用不需要特殊处理,也不会拦截App中的请求。 缺点:对于展示的第三方网页需要根据网页做一些适配, 例如部分网页展示图片使用的div的background-image。 UIWebView 展示效果 WKWebView 展示效果全文终 本文demo 下载","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"WebView","slug":"WebView","permalink":"http://yoursite.com/tags/WebView/"},{"name":"WebP","slug":"WebP","permalink":"http://yoursite.com/tags/WebP/"}]},{"title":"UIlabel设置行间距,字间距","date":"2017-04-10T06:49:21.000Z","path":"2017/04/10/labelSetAttribute/","text":"在iOS开发中经常会用到UIlabel来展示一些文字性的内容，但是默认的文字排版会觉得有些挤，为了更美观也更易于阅读我们可以通过某些方法将UIlabel的行间距和字间距按照需要调节。代码如下： 12345678910111213141516- (void)setLabelSpace:(UILabel *)label withValue:(NSString *)str withFont:(UIFont *)font&#123; NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init]; paraStyle.lineBreakMode = NSLineBreakByCharWrapping; paraStyle.alignment = NSTextAlignmentLeft; paraStyle.lineSpacing = UILABEL_LINE_SPACE; //设置行间距 paraStyle.hyphenationFactor = 1.0; paraStyle.firstLineHeadIndent = 0.0; paraStyle.paragraphSpacingBefore = 0.0; paraStyle.headIndent = 0; paraStyle.tailIndent = 0; //设置字间距 NSKernAttributeName:@1.5f NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.5f&#125;; NSAttributedString *attributeStr = [[NSAttributedString alloc] initWithString:str attributes:dic]; label.attributedText = attributeStr;&#125; 1234567891011121314151617//计算UILabel的高度（带有行间距的情况）-(CGFloat)getSpaceLabelHeight:(NSString*)str withFont:(UIFont*)font withWidth:(CGFloat)width &#123; NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init]; paraStyle.lineBreakMode = NSLineBreakByCharWrapping; paraStyle.alignment = NSTextAlignmentLeft; paraStyle.lineSpacing = UILABEL_LINE_SPACE; paraStyle.hyphenationFactor = 1.0; paraStyle.firstLineHeadIndent = 0.0; paraStyle.paragraphSpacingBefore = 0.0; paraStyle.headIndent = 0; paraStyle.tailIndent = 0; NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.5f&#125;; CGSize size = [str boundingRectWithSize:CGSizeMake(width, HEIGHT) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size; return size.height;&#125;","tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"},{"name":"UILabel","slug":"UILabel","permalink":"http://yoursite.com/tags/UILabel/"}]}]