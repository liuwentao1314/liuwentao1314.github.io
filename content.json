[{"title":"Swift学习之路--Swift基础(二)","date":"2017-06-22T05:37:47.000Z","path":"2017/06/22/SwiftIntroduceSecond/","text":"作者刘文涛转载请注明出处 前言Swift 包含了 C 和 Objective-C 上所有基础数据类型，int表示整型值；Double 和 Float表示浮点型的值。Bool是布尔型值； String是文本型数据。Swift还提供了三个基本的集合类型，Array， Set 和 Dictionary，详见集合类型。 就像 C 语言一样，Swift使用变量来进行存储并通过变量名来关联值。在Swift中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 的语言常量更强大。在Swift中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰的表达你的意图。除了我们熟悉的类型，Swift还增加了 OC 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。 Swift还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那有一个值，并且它等于 x”或者“那没有值”。可选有点像在 OC 中使用 nil，但是它可以用在任何类型上，不仅仅是类。可选类型对比 OC 中的 nil 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。 Swift 是一门类型安全的语言，这意味着 Swift 可以让你清除的知道值的类型。如果你的代码期望得到一个 String ，类型安全会阻止你不小心传入一个 Int。同样的，如果你的代码期望得到一个 String，类型安全会阻止你意外传入一个可选的String。类型安全可以帮助你在开发阶段尽早发现并修正错误。 常量和变量常量和变量把一个名字和一个指定类型的值关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。 声明常量和变量常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登陆的次数： 12let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0 这两行代码可以被理解为：“声明一个名字是 maximumNumberOfLoginAttempts 的新常量,并给它一个值 10 。然后,声明一个名字是 rrentLoginAttempt 的变量并将它的值初始化为 0 。” 在这个例子中，允许最大尝试登陆次数被声明为一个常量，因为这个值不会改变。当前尝试登陆次数被声明为一个变量，因为每次尝试登陆失败的时候都需要增加这个值。 你可以在一行中声明多个常量或者多个变量，使用逗号隔开： 1var x = 0.0, y = 0.0, z = 0.0 注意：如果你的代码中有不需要改变的值，请使用let关键字将它声明为常量。只将需要改变的值声明为变量。 类型标注当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。这个例子给welcomeMessage变量添加了类型标注，表示这个变量可以存储String类型的值： 1var welcomeMessage: String 声明中的冒号代表着”是…类型“，所以这行代码可以被理解为：”声明一个类型为String，名字为welcomeMessage的变量。“类型为String的意思是”可以存储任意String类型的值。“welcomeMessage 变量现在可以被设置成任意字符串： 1welcomeMessage = \"Hello\" 你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注： 1var red, green, blue: Double 注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型。在上面的例子中,没有给 welcomeMessage 赋初始 值,所以变量 welcomeMessage 的类型是通过一个类型标注指定的,而不是通过初始值推断的。 常量和变量的命名你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符： 12let π = 3.14let 你好 = \"你好\" 常量和变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。 一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何,你应当避免使用关键字作为常量或变量名,除非你别无选择。 你可以更改现有的变量值为其他同类型的值，在下面的例子中，friendlyWelcome的值从 &quot;Hello!&quot;改为了 &quot;Bonjour!&quot; 123var friendlyWelcome = \"Hello!\"friendlyWelcome = \"Bonjour!\"// friendlyWelcome 现在是 \"Bonjour!\" 与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译器报错： 1let languageName = \"Swift\" languageName = \"Swift++\" // 这会报编译时错误 - languageName 不可改变 输出常量和变量你可以用print()函数来输出当前常量或变量的值： 1print(friendlyWelcome) Swift 用字符串插值(string interpolation)的方式把常量名或者变量名当做占位符加入到长字符串中，Swift会用当前常量或者变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义： 12print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\") // 输出 \"The current value of friendlyWelcome is Bonjour! 注释请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift的注释与 C 语言的注释非常相似。单行注释以双正斜杠（//）作为起始标记： 1// 这是一个注释 你也可以进行多行注释,其起始标记为单个正斜杠后跟随一个星号( /*),终止标记为一个星号后跟随单个正斜 杠(*/): 12/* 这是一个, 多行注释 */ 与C语言多行注释不同，Swift的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中在嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记： 12345/* 这是第一个多行注释的开头 /* 这是第二个被嵌套的多行注释 */ 这是第一个多行注释的结尾*/ 通过运用嵌套多行注释，你可以快捷方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。 分号与其他大部分编程语言不同，Swift并不强制要求你在每条语句的结尾处使用分号（;），当然你也可以按照你自己的习惯添加分号。有一种情况下必须要使用分号，即你打算在同一行内写多条独立的语句： 12let cat = \"?\"; print(cat)输出 ? 整数整数就是没有小数部分的数字，比如 42,-23。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是 UInt8，32位有符号整数类型是 Int32。就像Swift的其他类型一样，整数类型采用大写命名法。 整数范围你可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值： 12let minValue = UInt8.min // minValue 为 0,是 UInt8 类型let maxValue = UInt8.max // maxValue 为 255,是 UInt8 类型 min 和 max所传回值的类型，正是其所对的整数类型（如上例UInt8, 所传回的类型是UInt8），可用在表达式中相同类型值旁。 Int一般来说，你不需要专门指定整数的长度。Swift提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：• 在32位平台上, Int 和 Int32 长度相同。• 在64位平台上, Int 和 Int64 长度相同。除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是32位平台上，Int可以存储的整数范围也可以达到 -2,147,483,648 ~ 2,147,483,647,大多数时候这已经足够大了。 UIntSwift 也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同：• 在32位平台上, UInt 和 UInt32 长度相同。• 在64位平台上, UInt 和 UInt64 长度相同。 注意：尽量不要使用UInt,除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用 Int ，即使你要存储的值已知是非负的。同意使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断。 浮点数","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(一)","date":"2017-06-15T02:42:16.000Z","path":"2017/06/15/SwiftIntroduceFirst/","text":"作者刘文涛转载请注明出处 前言刚接触Swift的时候是2.2版本，当时只是大概了解学习了一下一些Swift基础。现在由于项目不忙，决定在从基础重新学习一下Swift这门语言。这次学习的是Swift3.0版本，Swift3.0是自Swift开源以来第一个大的版本更新。从语言角度不兼容之前的Swift2.2和Swift2.3版本。Swift3.0版本的更新说明大家可以查看官方的blog说明，也可以关注SwiftGG的最新文章。 关于SwiftSwift是一种新的编程语言，用于编写iOS，macOS，watchOS和tvOS的应用程序。Swift结合了C和OC的优点并且不受C兼容性的限制。Swift采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift是基于成熟而且备受喜爱的Cocoa和Cocoa Touch框架，它的降临将重新定义软件开发。Objective-C开发者对Swift并不会感到陌生。它采用了Objective-C的命名参数以及动态对象模型，可以无缝对接到现有的Cocoa框架，并且可以兼容Objective-C代码。在此基础之上，Swift还有许多新特性并且支持过程式编程和面向对象编程。Swift对初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满变现力和趣味的系统编程语言。它支持代码预览(playgrounds)，这个革命性的特性可以使程序员在不编译运行应用的前提下运行Swift代码并实时查看结果。 Swift初见打印“hello world” 1print(&quot;hello world!&quot;) 如果你写过C或者Objective-C代码，那么你应该很熟悉这种形式——在Swift中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口点，所以你也不需要main()函数。你同样不需要在每个语句结尾写上分号。 简单值使用 let 来声明常量，使用 var 来声明变量。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能为它赋值一次。也就是说你可以用常量来表示这样的一个值：你只需要决定一次，但是需要使用很多次。 123var myVariable = 42myVariable = 50let myConstant = 42 常量或者变量的类型必须和你赋给他们的值一样。然而，你不用明确的声明类型，声明的同时赋值的话，编译器会自动推断类型。在上面的例子中，编译器推断出 myVariable 是一个整数（integer）因为它的初始值是整数。如果初始值没有提供足够的信息（或者没有初始值），那么需要你在变量后面声明类型，用冒号分割。 1let explicitDouble: Double = 70 值永远不会被隐式转换为其他类型。如果你需要把一个值转换成其他类型，请显式转换。 123let label = \"The width is\"let width = 100let widthLabel = label + String(width) 有一种更简单的把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠。例如： 1234let apples = 3let oranges = 5let appleSummary = \"I have \\(apples) apples.\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 使用方括号[]来创建数组和字典，并使用下标或者键（key）来访问元素。最后一个元素后面允许有个逗号。 12345678var shoppingList = [\"catfish\",\"water\",\"tulips\",\"blue paint\"]shoppingList[1] = \"bottle of water\" //将数组下标为1的元素替换了var occupations = [ \"Malcolm\": \"Captain\", \"Keylee\": \"Mechanic\",]occupations[\"Jayne\"] = \"Public Relations\" //添加一个字典occupations 要创建一个空数组或者字典，使用初始化语法。 12let emptyArray = [String]()let emptyDictionary = [String: Float]() 如果类型信息可以被推断出来,你可以用 [] 和 [:] 来创建空数组和空字典——就像你声明变量或者给函数传参 数的时候一样。 12shoppingList = []occupations = [:] 控制流使用 if 和 switch 来进行条件操作，使用 for-in 、for 、while 和 repeat-while 来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。 12345678910let individualScores = [75,43,122,109,12]var teamScore = 0for score in individualScores &#123; if score &gt; 50 &#123; teamScore += 3 &#125;else&#123; teamScore += 1 &#125;&#125;print(teamScore) 在 if 语句中，条件必须是一个布尔表达式—这意味着像 if score {...} 这样的代码将报错，而不会隐式地与0做对比。你可以一起使用 if 和 let 来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者是 nil 以表示值缺失。在类型后面加一个问号来标记这个变量的值是可选的。 123456789var optionalString: String? = \"Hello\"print(optionalString == nil)var optionalName: String? = \"liuwentao\"var greeting = \"Hello!\"if let name = optionalName &#123; greeting = \"Hello, \\(name)\"&#125; 如果变量的可选值是nil，条件会判断为 false，大括号中的代码会被跳过。如果不是 nil，会将值解包并赋给 let 后面的常量，这样代码块中就可以使用这个值了。另一种处理方法是通过使用 ?? 操作符来提供一个默认值。如果可选值缺失的话可以使用默认值来代替。 123let nickName: String? = nillet fullName: String = \"liuwentao\"let informalGreeting = \"Hi \\(nickName ?? fullName)\" switch 支持任意类型的数据以及各种比较操作————不仅仅是整数以及测试相等。 1234567891011let vegetable = \"red pepper\"switch vegetable &#123;case \"celery\": print(\"Add some raisins and make ants on a log.\")case \"cucumber\", \"watercress\": print(\"That would make a good tea sandwich.\")case let x where x.hasSuffix(\"pepper\"): print(\"Is it a spicy \\(x)?\")default: print(\"Everything tastes good in soup.\")&#125; 注意 let 在上述例子的等式中是如何使用的，它将匹配等式的值赋给常量 x。运行 switch 中匹配到的句子之后，程序会退出 switch 语句，并不会继续向下运行，所以不需要在每个句子结尾写 break。你可以使用 for-in 来遍历字典，需要两个变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。 1234567891011121314let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25],]var largest = 0for (kid, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) 使用 while 来重复运行一段代码知道不满足条件。循环条件也可以在结尾，保证能至少循环一次。 1234567891011var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n)var m = 2repeat &#123; m = m * 2&#125; while m &lt; 100print(m) 你可以在循环中使用..&lt;来表示范围。 123456//你可以在循环中使用 ..&lt; 来表示范围。var total = 0for i in 0..&lt;4 &#123; total += i&#125;print(total) 使用 ..&lt; 创建的范围不包含上界,如果想包含的话需要使用 ... 。 函数和闭包使用 func 来声明一个函数，使用名字和参数来调用函数。使用 -&gt;来指定函数的返回值类型。 1234func greet(person: String, day: String) -&gt; String &#123; return \"Hello \\(person), today is \\(day)\"&#125;greet(person: \"liuwentao\", day: \"2017-6-15\") 默认情况下,函数使用它们的参数名称作为它们参数的标签,在参数名称前可以自定义参数标签,或者使用_ 表示不使用参数标签 12345func greet(_ person: String, on day: String) -&gt; String &#123; return \"Hello \\(person), today is \\(day)\"&#125;greet(\"liuwentao\", on:\"wednesday\") 使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。 12345678910111213141516171819202122func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int)&#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125;else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;let statistics = calculateStatistics(scores: [2,9,5,100,3,9])print(statistics.max)print(statistics.min)print(statistics.2)print(statistics.1) 函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式： 123456789func sumOf(numbers:Int...) -&gt; Int&#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf()sumOf(numbers: 42,100,78) 函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。 123456789func returnFifteen() -&gt; Int&#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125;returnFifteen() 函数是第一等类型，这意味着函数可以作为另一个函数的返回值。 12345678func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment = makeIncrementer()increment(9) 函数也可以当成参数传入另一函数。 1234567891011121314func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item)&#123; return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool&#123; return number &lt; 10&#125;var numbers = [10,29,13,9]hasAnyMatches(list: numbers, condition: lessThanTen) 函数实际上是一种特殊的闭包：它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{}来创建一个匿名的闭包。使用 in 将参数和返回值类型声明与闭包函数体进行分离。 12345numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number return result&#125;) 有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。 12let mappedNumbers = numbers.map(&#123; number in 3 * number&#125;)print(mappedNumbers) 你可以通过参数位置而不是参数名字来引用参数————这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。 12let sortedNumbers = numbers.sorted&#123; $0 &gt; $1 &#125;print(sortedNumbers) 对象和类使用 class和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。 123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides\" &#125;&#125; 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。 123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription() 这个版本的 Shape 类缺少了一些重要的东西：一个构造函数来初始化类实例。使用 init 来创建一个构造器。 123456789101112131415class NameShape &#123; var numberOfSides: Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125; &#125;let testNameShape = NameShape( name: \"qq\")testNameShape.numberOfSides = 10testNameShape.simpleDescription() 注意 self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值————无论是通过声明（就像 numberOfSides）还是通过构造器（就像name）。如果你需要在删除对象之前进行一些清理工作，使用 deinit 创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。子类如果要重写父类方法的话，需要用 override 标记 ———— 如果没有添加 override 就重写父类方法的话编译器会报错。编译器同样会检测 override 标记的方法是否确实在父类中。 1234567891011121314151617181920class Square: NameShape &#123; var sideLength: Double init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func simpleDescription() -&gt; String &#123; return \"A square with sides of length \\(sideLength).\" &#125;&#125;let test = Square(sideLength:5.2, name: \"my test square\")test.area()test.simpleDescription() 除了储存简单的属性之外，属性可以有 getter 和 setter。 123456789101112131415161718192021222324252627class EquilateralTriangle:NameShape &#123; var sideLength: Double = 0.0 init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double &#123; get&#123; return 3.0 * sideLength &#125; set &#123; sideLength = newValue / 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"An equilateral triagle with sides of length \\(sideLength).\" &#125; &#125;var triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")print(triangle.perimeter)triangle.perimeter = 9.9print(triangle.sideLength) 在 perimeter的setter中，新值的名字是 newValue 。你可以在 set 之后显示的设置一个名字。注意 EquilateralTriangle 类的构造器执行了三步：1.设置子类声明的属性值2.调用父类的构造器3.改变父类定义的属性值。其他的工作比如调用方法、getters和setters也可以在这个阶段完成。如果你不需要计算属性，但是仍需要在设置一个新值之前或者之后运行代码，使用willSet和didSet。比如，下面的类确保三角形的边长总是和正方形的边长相同。 1234567891011121314151617181920212223class TriangleAndSquare &#123; var triangle : EquilateralTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square : Square &#123; willSet&#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size: Double, name: String) &#123; square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10,name: \"another test shape\")print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")print(triangleAndSquare.triangle.sideLength) 处理变量的可选值时，你可以再操作（比如方法、属性和子脚本）之前加 ?。如果?之前的值是nil,?后面的东西都会被忽略，并且整个表达式返回nil。否则，?之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。 12let optionalSquare: Square? = Square(sideLength: 2.5, name: \"optional square\")let sideLength = optionalSquare?.sideLength 枚举和结构体使用 enum来创建一个枚举。就想类和其他所有命名类型一样，枚举可以包含方法。 123456789101112131415161718enum Rank: Int &#123; case Ace = 1 case Two,Three,Fore,Five, Six, Seven func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return \"ace\" case .Two: return \"two\" case .Three: return \"three\" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.Acelet aceRawValue = ace.rawValue 默认情况下，Swift按照从0开始每次加1的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中，Ace被显式赋值为1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。使用init?(rawValue:)初始化构造器在原始值和枚举值之间进行转换。 123if let convertedRank = Rank(rawValue: 3)&#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。 12345678910111213141516enum Suit &#123; case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return \"spades\" case .Hearts: return \"hearts\" case .Diamonds: return \"diamonds\" case .Clubs: return \"clubs\" &#125; &#125; &#125;let hearts = Suit.Heartslet heartsDescription = hearts.simpleDescription() 注意，有两种方式可以引用Hearts成员：给hearts常量赋值时，枚举成员Suit.Hearts 需要用全名来引用，因为常量没有显示指定类型。在switch里，枚举成员使用缩写.Hearts来引用，因为self的值已经知道是一个Suit。已知变量类型的情况下你可以使用缩写。一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。例如，考虑从服务器获取日出日落的时间。服务器会返回正常结果或者错误信息。 123456789101112enum ServerResponse &#123; case Result(String, String) case Failure(String)&#125;let success = ServerResponse.Result(\"6:00 am\", \"8:09 pm\")let failure = ServerResponse.Failure(\"Out of cheese.\")switch success &#123;case let .Result(sunrise, sunset): let serverResponse = \"Sunrise is at \\(sunrise) and sunset is at \\(sunset).\"case let .Failure(message): print(\"Failure... \\(message)\")&#125; 注意日升和日落时间是如何从 ServerResponse 中提取到并与 switch的 case 相匹配的。 使用struct来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的区别就是结构体是传值，类是传引用。 12345678910struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return \"the \\(rank.simpleDescription()) of \\(suit.simpleDescription())\" &#125;&#125;let threeOfSpades = Card(rank: .Three,suit: .Spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 协议和扩展使用 protocol来声明一个协议。 1234protocol ExampleProtocol &#123; var simpleDescription:String &#123; get &#125; mutating func adjust()&#125; 类、枚举和结构体都可以实现协议。 12345678910111213141516171819202122class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = \"a very simple class\" var anotherProperty: Int = 69105 func adjust() &#123; simpleDescription += \" now 100% adjusted\" &#125; &#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct SimpleStructure:ExampleProtocol &#123; var simpleDescription: String = \"a very simple structure\" mutating func adjust() &#123; simpleDescription += \" (adjusted)\" &#125; &#125;var b = SimpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明 SimpleStructure 时候 ``mutating1234567891011121314使用 ``extension``来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。````objcextension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return &quot;The number \\(self)&quot; &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription)` 你可以像使用其他命名类型一样使用协议名–例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用。 123let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)// print(protocolValue.anotherProperty) // 去掉注释可以看到错误 即使protocolValue变量运行时的类型是simpleClass，编译器会把它的类型当做ExampleProtocol。这表示你不能调用类在它实现的协议之外实现的方法或者属性。 错误处理使用采用Error协议的类型来表示错误。 12345enum PrinterError:Error &#123; case OutOfPaper case NoToner case OnFire&#125; 使用throw来抛出一个错误并使用throws来表示一个可以抛出错误的函数。如果在函数中抛出一个错误，这个函数会立刻返回并且调用该函数的代码会进行错误处理。 123456func send(job: Int, toPrinter printerName: String) throws -&gt; String&#123; if printerName == \"Never Has Toner\" &#123; throw PrinterError.NoToner &#125; return \"job sent\"&#125; 有多种方式可以用来进行错误处理。一种方式是使用do-cash。在do代码块中，使用try来标记可以抛出错误的代码。在case代码块中，除非你另外命名，否则错误会自动命名为error。 123456do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Never Has Toner\") print(printerResponse)&#125; catch &#123;print(error)&#125; 可以使用多个catch块来处理特定的错误。参照switch中的case风格来写catch。 12345678910do &#123; let printerResponse = try send(job: 1440, toPrinter: \"Gutenberg\") print(printerResponse)&#125; catch PrinterError.OnFire &#123; print(\"I'll just put this over here, with the rest of the fire.\")&#125; catch let printerError as PrinterError &#123; print(\"Printer error: \\(printerError).\")&#125; catch &#123; print(error)&#125; 另一种处理错误的方式使用try?将结果转换为可选的。如果函数抛出错误，该错误会被抛弃并且结果为nil。否则的话，结果会是一个包含函数返回值的可选值。 12let printerSuccess = try? send(job: 1884, toPrinter: \"Mergenthaler\")let printerFailure = try? send(job: 1885, toPrinter: \"Never Has Toner\") 使用defer代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。使用defer，可以把函数调用之初就要执行的代码和函数调用结束时的扫尾代码写在一起，索然这两者的执行时机截然不同。 12345678910111213var fridgeIsOpen = falselet fridgeContent = [\"milk\", \"eggs\", \"leftovers\"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result &#125;fridgeContains(\"banana\")print(fridgeIsOpen) 泛型在尖括号里写一个名字来创建一个泛型函数或者类型。 12345678910func repeatItem&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result .append(item) &#125; return result&#125;print(repeatItem(repeating: \"knock\", numberOfTimes: 4)) 你也可以创建泛型函数、方法、类、枚举和结构体 123456enum OptionalValue&lt;Wrapped&gt; &#123; case None case Some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .NonepossibleInteger = .Some(100) 在类型名后面使用where来指定对类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。 1234567891011121314func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1, 2, 3], [3]) &lt;T: Equatable&gt; 和 &lt;T&gt; ... where T: Equatable&gt; 是等价的。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"iOS 动态下载系统提供的多种中文字体","date":"2017-06-07T05:53:08.000Z","path":"2017/06/07/DownloadFont/","text":"作者刘文涛转载请注明出处 一、功能简介1.前言为了实现更好的字体效果，有些应用在自己的应用资源包中加入了字体文件。但自己打包字体文件比较麻烦，原因在于：1.字体文件通常比较大，10~20M是常见的字体库大小。如果只是很少量的按钮字体需要设置，可以用一些工具把使用的汉字字体编码从字体库中抽取出来，以节省体积。但是如果是一些变化的内容需要自定义的字体，那么就只能打包整个字体库了。2.中文字体都是有版权的，在应用中加入特殊中文字体还需要处理相应的版权问题。从iOS6开始，苹果开始支持动态下载官方提供的中文字体到系统中。使用苹果官方的中文字体，即可以避免版权问题，又可以节省应用体积。 2.功能介绍使用动态下载中文字体的API可以动态的向iOS系统中添加字体文件，这些字体文件都是下载带到系统的目录中（模拟器中运行的目录是/Users/iosdev/Library/Developer/CoreSimulator/Devices/46DE5A8B-1C81-41F0-994D-BD6502EDEB58/data/Library/Assets/com_apple_MobileAsset_Font3/6da938c9f7fa36cae9ee066f7d75195c222fec07.asset/AssetData/WawaSC-Regular.otf）,所以并不会造成应用体积的增加。虽然第一次下载相关的中文字体需要一些网络开销和下载时间，但是这些字体文件下载完后可以在所有应用间共享，所以大部分应用都不需提示用户下载字体，因为很可能这些字体在之前被其他应用下载过了。 3.字体列表在官方文档中，苹果列出了提供动态下载和使用的中文字体文件列表。不过，由于下载的时候需要使用的名字是PostScript名称，所以如果你真正要动态下载相应的字体的话，还需要使用Mac内自带的应用字体册(Font Book)来获得相应字体的PostScript名称。下面是从字体册中获取“娃娃体-简 常规体”字体的PostScript名称的截图。 二、使用教程1.相关API介绍苹果提供了动态下载代码的Demo工程。将此Demo工程下载下来，可以学习相关API的使用。下面对该工程中相关API做简单的介绍。假如我们现在要下载“娃娃体”，他的PostScript名称为“DFWaWaSC-W5”。具体操作步骤如下。1.我们先判断该字体是否已经被下载下来，示例代码： 123456789//判断字体是否已经被下载- (BOOL)isFontDownloaded:(NSString *)fontName&#123; UIFont *aFont = [UIFont fontWithName:fontName size:12.]; if (aFont &amp;&amp; ([aFont.fontName compare:fontName] == NSOrderedSame || [aFont.familyName compare:fontName] == NSOrderedSame)) &#123; return YES; &#125;else&#123; return NO; &#125;&#125; 2.如果该字体已经下载过了，则可以直接使用。否则我们需要先准备下载字体API需要的一些参数，示例代码： 12345678//用字体的PostScript名字创建一个 dictionaryNSMutableDictionary *attrs = [NSMutableDictionary dictionaryWithObjectsAndKeys:fontName,kCTFontNameAttribute, nil];//创建一个字体描述对象 CTFontDescriptorRefCTFontDescriptorRef desc = CTFontDescriptorCreateWithAttributes((__bridge CFDictionaryRef)attrs);//将字体描述对象放到一个NSMutableArray中NSMutableArray *descs = [NSMutableArray arrayWithCapacity:0];[descs addObject:(__bridge id _Nonnull)desc];CFRelease(desc); 3.准备好上面的descs变量后，就可以进行字体的下载了，示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556__block BOOL errorDuringDownload = NO; //下载字体 CTFontDescriptorMatchFontDescriptorsWithProgressHandler((__bridge CFArrayRef)descs , NULL, ^bool(CTFontDescriptorMatchingState state, CFDictionaryRef _Nonnull progressParameter) &#123; double progressValue = [[(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingPercentage] doubleValue]; switch (state) &#123; case kCTFontDescriptorMatchingDidBegin: //字体已经匹配 break; case kCTFontDescriptorMatchingWillBeginDownloading: //字体开始下载 break; case kCTFontDescriptorMatchingDownloading: NSLog(@\" 下载进度 %.0f\",progressValue); break; case kCTFontDescriptorMatchingDidFinishDownloading: //字体下载完成 break; case kCTFontDescriptorMatchingDidFinish: &#123; //字体已经下载完成 if (!errorDuringDownload) &#123; NSLog(@\"字体%@ 已经下载完成\",fontName); dispatch_async( dispatch_get_main_queue(), ^ &#123; // 可以在这里修改 UI 控件的字体 _label.font = [UIFont fontWithName:_postName size:14]; return ; &#125;); &#125; &#125; break; case kCTFontDescriptorMatchingDidFailWithError: //下载错误 &#123; NSError *error = [(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingError]; if (error != nil) &#123; _errorMessage = [error description]; &#125; else &#123; _errorMessage = @\"ERROR MESSAGE IS NOT AVAILABLE!\"; &#125; // 设置标志 errorDuringDownload = YES; NSLog(@\" 下载错误: %@\", _errorMessage); &#125; break; default: break; &#125; return YES; &#125;); 通常需要在下载完字体后开始使用字体，一般是将相应的代码放到kCTFontDescriptorMatchingDidFinish 条件中，可以像苹果官方Demo那样，用GCD来修改UI逻辑，也可以发 Notification 来通知相应的Controller。程序运行截图： 本文参考《iOS开发进阶》– 唐巧本文demo下载地址","tags":[{"name":"UIFont","slug":"UIFont","permalink":"http://yoursite.com/tags/UIFont/"},{"name":"下载字体","slug":"下载字体","permalink":"http://yoursite.com/tags/下载字体/"}]},{"title":"iOS使用UIWindow","date":"2017-06-06T02:29:55.000Z","path":"2017/06/06/UIWindow/","text":"作者刘文涛转载请注明出处 UIWindow简介在iOS应用中，我们使用UIWindow和UIView来呈现界面。UIWindow是最顶层的界面容器。UIWindow并不包含任何默认的内容，但是它被当做UIView的容器，用于放置应用中的所有UIView。而每一个UIView通常都用来表示具体的某一部分界面，例如一段文字、一张图片等。当然你可以用UIView来当做其他UIView的容器。所以UIWindow更多的时候只是作为UIView的顶层容器存在。 NS_CLASS_AVAILABLE_IOS(2_0) @interface UIWindow : UIView 在继承关系上，我们能看到UIWindow继承自UIView，所以UIWindow除了具有UIView的功能外，还增加了一些特有的属性和方法。而我们最常用的方法就是在程序刚启动时，调用UIWindow的makeKeyAndVisible方法，使整个程序界面可见，代码如下所示： 123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; ViewController *vc = [[ViewController alloc] init]; vc.view.backgroundColor=[UIColor whiteColor]; self.window.rootViewController = vc; [self.window makeKeyAndVisible]; return YES;&#125; 所以UIWindow的主要作用有：1.做完UIView的最顶层容器，包含应用显示所需要的所有UIView。2.传递触摸消息和键盘事件给UIView。 为UIWindow增加UIView通常我们有两种方法给UIWindow增加子UIView：1.通过调用addSubView方法。因为UIWindow是UIView的子类，所以它可以使用UIView的addSubView方法给自己增加子VIew，从而承担容器的作用。2.通过设置其特有的rootViewController属性。通过设置该属性为要添加view对应的UIViewController，UIWindow将会自动将其view添加到当前window中，同时负责维护VIewController和view的生命周期。我们在之前的application: didFinishLaunchingWithOptions:示例代码中看到的就是这种方法。 系统对UIWindow的使用通常在一个程序中只会有一个UIWindow，但是有些时候我们调用系统的控件（例如UIAlertView）时，iOS系统为了保证UIAlertView在所有的界面之上，他会临时创建一个新的UIWindow，通过将其UIWindow的UIWindowLevel设置的更高，让UIAlertView盖在所有的应用界面之上。为了验证这一说法，我们创建了一个新的测试Xcode工程,在其主ViewController上添加一个button，点击button弹出一个系统的弹框。示例代码： 1234567- (IBAction)testButtonClicked:(UIButton *)sender &#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:@\"测试\" preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@\"取消\" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125; WindowLevel那么是不是新创建的UIWindow一定会在界面的最上层呢？其实不是这样的。UIWindow有一个WindowLevel的属性该属性定义了UIWindow的层级，系统定义的WindowLevel一共有三种取值： 123UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar __TVOS_PROHIBITED; 我们将这些值通过代码打印输出： 123NSLog(@\"UIWindowLevelNormal=%f\",UIWindowLevelNormal);NSLog(@\"UIWindowLevelAlert=%f\",UIWindowLevelAlert);NSLog(@\"UIWindowLevelStatusBar=%f\",UIWindowLevelStatusBar); 输出的结果： 2017-06-06 11:43:09.345 UIWindowDemo[899:667871] UIWindowLevelNormal=0.000000 2017-06-06 11:43:09.346 UIWindowDemo[899:667871] UIWindowLevelAlert=2000.000000 2017-06-06 11:43:09.346 UIWindowDemo[899:667871] UIWindowLevelStatusBar=1000.000000 从中我们可以看出来默认程序的UIWindow的层级是UIWindowLevelNormal，当系统需要在上面覆盖UIAlertView时，就会创建一个层级是UIWindowLevelAlert的UIWindow，因为其WindowLevel的值更高，所以就覆盖在上面了。在实际应用中，WindowLevel的取值并不限于上面提到的3个值。 手动创建UIWindow有些时候我们也希望在应用开发中，将某个界面覆盖在所有的界面最上层。这个时候我们就可以手动创建一个新的UIWindow。需要注意的是，和创建UIView不同，UIWindow一旦被创建，它就会自动被添加到整个界面上了。例如想做一个密码保护功能，在用户按home键退出应用界面，过一段时间后从后台切换回来时，显示一个密码输入界面。用户只有输入正确的密码才能进入退出的前台界面。因为这个密码输入界面可能从任何应用界面弹出，并且需要遮在所有界面的最上层，所以它很适合用UIWindow来实现。","tags":[{"name":"UIWindow","slug":"UIWindow","permalink":"http://yoursite.com/tags/UIWindow/"}]},{"title":"iOS开发-发送邮件及短信","date":"2017-06-01T08:22:20.000Z","path":"2017/06/01/mailAndMessage/","text":"作者刘文涛转载请注明出处 前言在iOS开发中，有时候我们会需要用到发送邮件及短信的功能。我们还可以通过发送邮件来接收用户反馈的崩溃通知等等。我用的是iOS原生自带的MFMailComposeViewController来实现的。他不会使程序进入后台，使用模态弹出邮件或短信发送界面。 代码示例1.发送邮件使用前需要导入框架：MessageUI.framework在使用的controller中导入头文件： #import &lt;MessageUI/MessageUI.h&gt;实现代理：&lt;MFMailComposeViewControllerDelegate,MFMessageComposeViewControllerDelegate&gt;获取用户是否设置了邮箱账户： 123456if ([MFMailComposeViewController canSendMail]) &#123; // 用户已设置邮件账户 [self sendEmailAction]; // 调用发送邮件的代码 &#125;else&#123; NSLog(@\"用户未设置邮箱账户\"); &#125; sendEmailAction方法代码： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)sendEmailAction&#123; // 邮件服务器 MFMailComposeViewController *mailCompose = [[MFMailComposeViewController alloc] init]; // 设置邮件代理 [mailCompose setMailComposeDelegate:self]; // 设置邮件主题 [mailCompose setSubject:@\"我是邮件主题\"]; // 设置收件人 [mailCompose setToRecipients:@[@\"邮箱号码\"]]; // 设置抄送人 [mailCompose setCcRecipients:@[@\"邮箱号码\"]]; // 设置密抄送 [mailCompose setBccRecipients:@[@\"邮箱号码\"]]; /** * 设置邮件的正文内容 */ NSString *emailContent = @\"邮件内容...\"; // 是否为HTML格式 [mailCompose setMessageBody:emailContent isHTML:NO]; // 如使用HTML格式，则为以下代码// [mailCompose setMessageBody:@\"&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\" isHTML:YES]; /** * 添加附件 */ UIImage *image = [UIImage imageNamed:@\"image\"]; NSData *imageData = UIImagePNGRepresentation(image); [mailCompose addAttachmentData:imageData mimeType:@\"\" fileName:@\"custom.png\"]; NSString *file = [[NSBundle mainBundle] pathForResource:@\"test\" ofType:@\"pdf\"]; NSData *pdf = [NSData dataWithContentsOfFile:file]; [mailCompose addAttachmentData:pdf mimeType:@\"\" fileName:@\"pdf文件\"]; // 弹出邮件发送视图 [self presentViewController:mailCompose animated:YES completion:nil];&#125; MFMailComposeViewControllerDelegate的代理方法： 12345678910111213141516171819202122 - (void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error&#123; switch (result) &#123; case MFMailComposeResultCancelled: NSLog(@\"取消发送\"); break; case MFMailComposeResultFailed: NSLog(@\"发送失败\"); break; case MFMailComposeResultSaved: NSLog(@\"保存草稿文件\"); break; case MFMailComposeResultSent: NSLog(@\"发送成功\"); break; default: break; &#125; // 关闭邮件发送视图 [self dismissViewControllerAnimated:YES completion:nil];&#125; 2.发送短信获取用户能否发送短信： 12345if ([MFMessageComposeViewController canSendText]) &#123; [self sendMessageAction];&#125;else&#123; NSLog(@\"用户不能发送短信\");&#125; sendMessageAction方法代码: 1234567891011121314// 调用系统API发送短信- (void)sendMessageAction&#123; MFMessageComposeViewController *messageVC = [[MFMessageComposeViewController alloc] init]; // 设置短信代理 messageVC.messageComposeDelegate = self; // 发送给谁 messageVC.recipients = @[@\"18701235678\"]; // 发送的内容 messageVC.body = @\"hello world\"; // 弹出发送短信的视图 [self presentViewController:messageVC animated:YES completion:nil];&#125; MFMessageComposeViewControllerDelegate的代理方法： 12345678910111213141516171819- (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result&#123; switch (result) &#123; case MessageComposeResultCancelled: NSLog(@\"取消发送\"); break; case MessageComposeResultFailed: NSLog(@\"发送失败\"); break; case MessageComposeResultSent: NSLog(@\"发送成功\"); break; default: break; &#125; [self dismissViewControllerAnimated:YES completion:nil]; &#125; 结语以上代码均在真机（iOS9）进行测试，并通过测试。注意发送邮件的时候需要你绑定邮箱账户。本文demo。","tags":[{"name":"MessageUI","slug":"MessageUI","permalink":"http://yoursite.com/tags/MessageUI/"}]},{"title":"iOS多线程编程 GCD介绍","date":"2017-05-19T06:52:46.000Z","path":"2017/05/19/GCDInfo/","text":"作者刘文涛转载请注明出处 一、简单介绍1.什么是GCDGrand Central Dispatch是由苹果开发的一个多核编程的解决方案。iOS4.0+才能使用，是替代NSThread， NSOperation的高效和强大的技术。苹果官方给出的解释：GCD是异步执行任务的技术之一。一般将应用程序中记述的线程管理代码在系统集中实现，开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就可以生成必要的线程并计划执行任务。GCD是基于C语言的。 2.GCD的优点它具有以下优点：1.GCD可以将花费时间及其长的任务放到后台线程，可以改善应用的响应性能。2.GCD提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。3.GCD具有在常见模式（例如单例）上用更高性能的底层语法优化你的代码的潜在能力等等。我创建一个并行队列queue，并异步执行耗时操作，当耗时操作执行完成后，我拿到其中的资源回到主线程来更新相应的UI，在这个block代码块之外，主线程并不会被耗时任务所堵塞，可以流畅的处理其他的事情。代码片段如下： 1234567891011121314151617dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); //用异步的方法执行任务 dispatch_async(queue, ^&#123; /** 放一些耗时的任务在此执行 */ dispatch_async(dispatch_get_main_queue(), ^&#123; /** 耗时的任务完成，拿到资源，回到主线程，更新UI 注意：更新UI只能在主线程中 */ &#125;); &#125;); 二、任务和队列GCD有两个核心的概念：1.任务：执行什么操作2.队列：用来存放任务GCD的使用步骤：1.定制任务2.确定想做的事情 将任务添加到队列中，GCD会自动将队列中的任务取出，放到相应的线程中去执行。提示：任务的取出遵循队列的FIFO（first in,first out）原则：先进先出，后进后出。 三、执行任务1.GCD中有2个用来执行任务的函数 说明：把右边的参数（任务）提交给左边的参数（队列）进行执行。 （1）用同步的方法执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 参数说明： queue：队列 block：任务 （2）用异步的方法执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 2.同步和异步的区别 同步：在当前线程中执行 异步：在另一条线程中执行 四、队列1.队列的类型GCD的队列可以分为2大类（1）并发队列 （ DISPATCH_QUEUE_CONCURRENT ） 可以让多个任务并发执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch——async）函数下才有效（2）串行队列 （ DISPATCH_QUEUE_SERIAL ） 让任务一个接一个的执行 （一个任务执行完毕后，在执行下一个任务） 2.补充说明同步和异步决定了要不要开启新的线程。同步：在当前线程中执行任务，不具备开启新线程的能力异步：在新的线程中执行任务，具备开启新线程的能力 并发和串行决定了任务的执行方式并发：多个任务同时执行串行：一个任务执行完毕后，在执行下一个任务 3.串行队列GCD中获得串行有两种途径（1）使用dispatch_queue_create函数创建串行队列 1dispatch_queue_t queue = dispatch_queue_create(&lt;#const char * _Nullable label#&gt;, &lt;#dispatch_queue_attr_t _Nullable attr#&gt;) //// 队列名称， 队列属性，一般用NULL即可 示例：1dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", NULL); （2）使用主队列主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务都会放到主线程中执行 使用dispatch_get_main_queue()获得主队列示例： 1dispatch_queue_t queue2 = dispatch_get_main_queue(); 4.并发队列GCD默认已经提供全局的并发队列，供整个应用使用，不需要手动创建使用dispatch_get_global_queue函数获得全局的并发队列示例： 1234567dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);说明：全局并发队列的优先级 #define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高 #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中） #define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低 #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台 5.各队列的执行效果 全局并发队列 手动创建串行队列 主队列 同步（sync） 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 异步（async) 开启新线程，并发执行任务 开启新线程，串行执行任务 没有开启新线程，串行执行任务 五、示例代码1.用异步函数往并发队列中添加任务示例： 1234567891011121314151617181920//1.获得全局的并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //2.添加任务到队列中，就可以执行任务 //异步函数：具备开启新线程的能力 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"主线程----%@\",[NSThread mainThread]); 输出：结论：在并发队列+异步执行中可以看出，除了主线程同时又开启了三个子线程，并且任务交替着同时执行。并且任务不是马上执行的，而是将所有的任务添加到队列之后才开始异步执行的。 2.用异步函数往串行队列中添加任务示例： 123456789101112131415161718192021222324252627//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1、创建串行队列 /** 第一个参数为串行队列的名称，是c语言的字符串 第二个参数为队列的属性，一般来说串行队列不需要赋值任何属性，所以通常传空值（NULL） */ dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", NULL); //2、添加任务到队列中执行 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：在串行队列+异步执行可以看到，只开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。并且是将所有任务添加到队列之后才开始同步执行。 3.用同步函数往并发队列中添加任务示例： 1234567891011121314151617181920212223//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：所有的任务都是在主线程中执行的，由于只有一个线程，所以任务只能一个一个执行，执行完一个任务，再执行下一个任务。并且并发队列是去了并发的功能。并且任务是添加到队列中马上执行的。 4.用同步函数往串行队列中添加任务示例： 1234567891011121314151617181920212223//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_SERIAL); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：所有的任务都是在主线程中执行的，并没有开启新的线程，并且按顺序一个一个执行。并且任务是添加到队列中马上执行的。 5.同步函数在主队列中执行示例： 12345678910111213141516171819202122232425- (void)syncMain&#123; //打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //获取主线程 dispatch_queue_t queue = dispatch_get_main_queue(); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;);&#125; 输出：这时候，我们发现在主线程中使用主队列+同步执行，任务不再执行了，这是为什么呢？这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主线程中他会立马执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个任务和第三个任务。那么现在的情况就是syncMain方法和第一的任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，我们的任务执行不了了。 不在主线程中调用，而在其他线程中调用1234dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [self syncMain]; &#125;); 123456789101112131415161718192021222324252627- (void)syncMain&#123; NSLog(@\"syncMain---begin\"); //打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //获取主线程 dispatch_queue_t queue = dispatch_get_main_queue(); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"syncMain---begin\");&#125; 输出：结论：所有的任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个的执行。同时我们还可以看到，所有的任务都是打印在syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。 6.异步函数在主队列中执行示例： 123456789101112131415161718192021222324- (void)asyncMain&#123; NSLog(@\"asyncMain---begin\"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"asyncMain---end\");&#125; 输出：结论：所有的任务都是在主线程中，虽然是异步执行，具备开启线程的能力，但是因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。 6.GCD的其他方法1.GCD的栅栏方法我们有时候需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。 123456789101112131415161718192021222324252627- (void)barrier&#123; dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@\"barrier-----%@\",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"4------%@\",[NSThread currentThread]); &#125; &#125;);&#125; 输出：结论：可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后在执行栅栏后面的操作。 2.GCD的延时执行方法当我们需要延时执行一段代码时，就需要用到GCD的dispatch_after方法示例： 1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.9 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //2 秒后执行这里的代码 NSLog(@\"run-----\"); &#125;); 3.GCD只执行一次我们在创建单例或者整个程序运行过程中只执行一次的代码时，我们就用到了GCD的dispatch_once方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。示例： 1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //只执行1次的代码（这里面默认是线程安全的） &#125;); 4.GCD的快速迭代方法通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法dispatch_apply，使我们可以同时遍历。比如遍历0~5这6个数字，for循环是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。示例： 12345dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_apply(6, queue, ^(size_t index) &#123; NSLog(@\"%zd--------%@\",index,[NSThread currentThread]); &#125;); 输出：结论：从输出结果的时间可以看出，几乎是同时遍历出的。 5.GCD的队列组有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后在回到主线程执行操作。这时候我们可以用到GCD的队列组。我们可以先把任务放到队列中，然后将队列放入队列组中。调用队列组的dispatch_group_notify回到主线程执行操作。示例： 123456789101112//创建一个队列组 dispatch_group_t group = dispatch_group_create(); //添加任务到队列组中 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行1个耗时的异步操作 &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行1个耗时的异步操作 &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //等前面的异步操作都执行完毕后，回到主线程中... &#125;); 结语以上就是我对GCD的基础知识和几种组合的理解，如果觉得我有哪里理解的错误欢迎留下你的评论。","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"}]},{"title":"iOS多线程编程 NSOperation","date":"2017-05-11T02:28:31.000Z","path":"2017/05/11/NSOperation/","text":"作者刘文涛转载请注明出处 一、NSOperation1、简介NSOperation实例封装了需要执行的操作和执行操作所需的数据，并且能够以并发或非并发的方式执行这个操作。NSOperation本身是抽象基类，因此必须使用它的子类，使用NSOperation子类的方式有两种：1.Foundation框架提供了两个具体子类直接供我们使用：NSInvocationOperation和NSBlockOperation2.自定义子类继承NSOperation，实现内部相应的方法 2、执行操作NSOperation调用start方法即可开始执行操作，NSOperation对象默认按同步方式执行，也就是调用start方法的那个线程中直接执行。NSOperation对象的isConcurrent方法会告诉我们这个操作相对于调用start方法的线程，是同步还是异步执行。isConcurrent默认是返回NO,表示操作与调用线程同步执行 123NSOperation * operation = [[NSOperation alloc]init];//开始执行 [operation start]; 3、取消操作Operation开始执行之后，默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作 1[operation cancel]; 4、监听操作的执行如果我们想在一个NSOperation执行完毕后做一些事，就调用NSOperation的setCompletionBlock方法： 123[operation setCompletionBlock:^&#123; NSLog(@\"执行结束\");&#125;]; 二、NSInvocationOperation1.简介基于一个对象和selector来创建操作。如果你已经有现有的方法来执行需要的任务，就可以使用这个类 2.创建并执行操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 //调用self的run方法 NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //开始执行任务（同步执行） [operation start];```` ## 三、NSBlockOperation### 1.简介能够并发的执行一个或者多个block对象，所有相关的block都执行完之后，操作才算完成。### 2.创建并执行操作````objc NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"执行一个新的操作\"); &#125;]; //开始执行任务（同步执行） [operation start]; ```` ### 3.通过addExecutionBlock方法添加block操作````objc NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"执行一个新的操作\"); &#125;]; [operation addExecutionBlock:^&#123; NSLog(@\"添加1个新的操作\"); &#125;]; //开始执行任务（同步执行） [operation start];```` 这两个block是并发执行的，也就是在不同的线程中执行的## 四、自定义NSOperation### 1.简介如果NSInvocationOperation和NSBlockOperation对象不能满足需求, 你可以直接继承NSOperation, 并添加任何你想要的行为。继承所需的工作量主要取决于你要实现非并发还是并发的NSOperation。定义非并发的NSOperation要简单许多，只需要重载- (void)main这个方法，在这个方法里面执行主任务，并正确的响应取消事件；对于并发的NSOperation，你必须重新NSOperation的多个基本方法进行实现。### 2.非并发的NSOperation创建一个继承NSOperation的类：LWTNoCurrentOperation，重写main方法，在main方法中执行自定义的任务。LWTNoCurrentOperation.m````objc//自定义main方法执行你的任务- (void)main&#123; //在这里我们要创建自己的释放池，因为这里我们拿不到主线程的释放池 @autoreleasepool &#123; BOOL isDone = NO; //正确响应取消事件 while (![self isCancelled] &amp;&amp; !isDone) &#123; //在这里执行自己的任务操作 NSLog(@\"执行自定义非并发\"); NSThread *thread = [NSThread currentThread]; NSLog(@\"%@\",thread); //任务执行完后将isDone设为YES isDone = YES; &#125; &#125;&#125; 在ViewDidLoad中使用我们自定义的operation,并调用start方法。 12LWTNoCurrentOperation *operation = [[LWTNoCurrentOperation alloc] init]; [operation start]; 默认情况下，该OperaTion在当前调用start的线程中执行，其实如果我们创建多个自定义的LWTNoCurrentOperation，并放入NSOperationQueue中，这些任务也是并发执行的，只不过我们没有处理，线程执行完，KVO等操作。因此不建议在只实现main函数的情况下将其加入NSOperationQueue，只实现main一般只适合自定义非并发的NSOperation。 12345678910111213141516@property (nonatomic, strong) NSOperationQueue *myQueue;- (void)viewDidLoad &#123; [super viewDidLoad]; self.myQueue = [[NSOperationQueue alloc] init]; LWTNoCurrentOperation *operation1 = [[LWTNoCurrentOperation alloc] init]; [self.myQueue addOperation:operation1]; LWTNoCurrentOperation *operation2 = [[LWTNoCurrentOperation alloc] init]; [self.myQueue addOperation:operation2]; LWTNoCurrentOperation *operation3 = [[LWTNoCurrentOperation alloc] init]; [self.myQueue addOperation:operation3]; &#125; 3.并发的NSOperation","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"}]},{"title":"iOS多线程编程 NSThread介绍","date":"2017-05-10T01:35:33.000Z","path":"2017/05/10/NSThread/","text":"作者刘文涛转载请注明出处 一、简单介绍iOS支持多个层次的多线程编程，层次越高的抽象程度越高，使用也越方便，也是苹果最推荐的使用方法。下面根据抽象层次从低到高依次列出iOS所支持的多线程编程方法：1.Thread：是三种方法里相对轻量级的，但是需要管理线程的生命周期、同步、加锁问题，这会导致一定的性能开销；2.Cocoa Operations：是基于OC实现的，NSOperation以面向对象的方式封装了需要执行的操作，不必关心线程管理、同步等问题。NSOperation是一个抽象基类，iOS提供了两种默认实现：NSInvocationOperation和NSBlockOperation，当然也可以自定义NSOperation；3.Grand Central Dispatch（简称GCD，iOS4才开始支持的）：提供了一些新特性、运行库来支持多核并行编程，它的关注点更高：如何在多个CPU上提升效率； 这篇文章简单的介绍了第一种多线程的编程方式，主要利用NSThread这个类，一个NSThread实例代表着一条多线程。 二、NSthread的初始化1.动态方法- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0); 参数解析： target：selector消息发送的对象 selector：线程执行的方法，这个selector最多只能接收一个参数 argument：传给selector的唯一参数，也可以是nil 123456//初始化线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; //设置线程的优先级（0.0 -- 1.0 ,1.0是最高级） thread.threadPriority = 1.0; //开启线程 [thread start]; 2.静态方法+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 12[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];//调用完毕后，会马上创建并开启新的线程 3.隐式创建线程的方法[self performSelectorInBackground:@selector(run) withObject:nil]; 三、获取当前线程NSThread *current = [NSThread currentThread]; 四、获取主线程NSThread *mainThread = [NSThread mainThread]; 五、暂停当前线程//暂停2.0s [NSThread sleepForTimeInterval:2.0]; //或者 NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]]; [NSThread sleepUntilDate:date]; 六、线程间的通信1.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 2.在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 3.在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 七、优缺点优点：NSTread比其他两种多线程方案较轻量级，更直观的控制线程对象缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据加锁或有一定的系统开销。","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"NSThread","slug":"NSThread","permalink":"http://yoursite.com/tags/NSThread/"}]},{"title":"iOS开发masonry动态布局cell高度","date":"2017-04-15T07:39:36.000Z","path":"2017/04/15/masonryForCell/","text":"作者刘文涛转载请注明出处 前言说到iOS自动布局，有很多的解决办法。有的人使用xib/storyboard自动布局，也有人使用frame来适配。对于前者，笔者并不喜欢，也不支持。对于后者，更是麻烦，到处计算高度、宽度等，千万大量代码的冗余，对维护和开发的效率都很低。笔者在这里介绍纯代码自动布局的第三方库：Masonry。这个库使用率相当高，在全世界都有大量的开发者在使用，其star数量也是相当高的。本文Cell内容通过Masonry自动布局并且cell巧妙利用自动布局计算cell的动态高度。 正文实现思路：例如cell中有三个label，label1，label2，label3.1.为label1添加约束（以cell.cntentView为基准） 123456CGFloat one_W = SCREENWIDTH/2;[self.L1 makeConstraints:^*(MASConstraintMaker *make)&#123; make.left.mas_equalTo(16); make.top.mas_equalTo (10); make.width.mas_lessThanOrEqualTo(one_W);&#125;]; 2.为label2添加约束 使其在label1下方距离为5处 （以label1为基准）。 12345[self.L2makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(wself.L1.mas_left); make.top.equalTo(wself.L1.mas_bottom).offset(5); make.width.mas_lessThanOrEqualTo(one_W);&#125;]; 3.为label3添加约束 使其在label2 下方距离为5处 （以label2为基准，重点在于这个一定要在label3 添加一个距离cell。contentView底部的约束）。以上完成cell 子视图的约束。 123456[self.L3 makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(wself.L1.mas_left); make.top.equalTo(wself.L2.mas_bottom).offset(5); make.width.mas_lessThanOrEqualTo(SCREENWIDTH-32);make.bottom.equalTo(wself.contentView.mas_bottom).offset(-10);&#125;]; 4.在tableView heightForRowAtIndexPath 代理中使用一个单独的不显示在屏幕的cell 作为计算cell高度使用，通过下面代码获取cell高度： 1234567891011customCell *cell= [customCellshareInstance]; //返回cell之前重新刷新约束，重新计算高度 [cell setNeedsUpdateConstraints]; [cell updateConstraintsIfNeeded]; [cell setCellContent:self.data[indexPath.row]]; [cell setNeedsLayout]; [cell layoutIfNeeded]; CGFloat height = [cell.contentViewsystemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; return height; 本文demo","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"masonry","slug":"masonry","permalink":"http://yoursite.com/tags/masonry/"},{"name":"动态布局","slug":"动态布局","permalink":"http://yoursite.com/tags/动态布局/"}]},{"title":"如何使UIWebview/WKWebView支持WebP格式图片","date":"2017-04-13T05:43:26.000Z","path":"2017/04/13/webp-image-format-ios/","text":"作者Talent•C转载自Talent•C 前言在一般的app中占用流量最大的内容一般都是图片,以苹果公司 Retina 产品为代表的高 PPI 屏对图片的质量提出了更高的要求，如何保证在图片的精细度不降低的前提下缩小图片体积，成为了一个有价值且值得探索的事情。但如今对于 JPEG、PNG 和 GIF 这些图片格式的优化几乎已经达到了极致， 若想改变现状开辟新局面，便要有釜底抽薪的胆量和气魄，而 Google 给了我们一个新选择：WebP。 正文WebP是什么? WebP（发音 weppy，来自:Google WebP），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。在 Google 的明星产品如 Youtube、Gmail、Google Play 中都可以看到 WebP 的身影，而 Chrome 网上商店甚至已完全使用了 WebP。国外公司如 Facebook、ebay 和国内公司如腾讯、淘宝、美团等也早已尝鲜。下面是QQ图片格式对比图 iOS中如何使用WebP格式图片?很幸运,SDWebImage支持WebP格式图片,可以讲WebP数据–&gt;NSData–&gt;UIImage There are 3 subspecs available now: Core, MapKit and WebP (this means you can install only some of the SDWebImage modules. By default, you get just Core, so if you need WebP, you need to specify it).Podfile example:$pod ‘SDWebImage/WebP’摘自SDWebImage 我们需要手动下载WebP这个库,由于是从Google下载的,如果下载失败,请翻墙重试!!!下载后的文件路径 Xcode 需要如下配置 targets-&gt;build settings -&gt;preprocessor Macros 填写 SD_WEBP=1 如图到此app 中支持 WebP图片基本完成,但是重点来了,由于部分app使用到了UIWebview/WKWebview 这两个控件是不支持WebP图片的,目前有两种方式可以让其支持WebP格式图片。 实现方式一 NSURLProtocol对于NSURLProtocol的作用及使用以后找个时间再讲了~~~~可以参考Apple 开发者文档NSURLProtocol, UIWebView 直接就可以支持,但是WKWebView是不支持的,如何让WKWebView也支持NSURLProtocol可以参考这篇文章,不过WKWebView自定义NSURLProtocol会丢失boay数据。文章结尾会附上Demo下载地址。 WKWebView 拓展支持NSURLProtocol 具体代码如下12345678910111213141516171819202122232425262728293031323334FOUNDATION_STATIC_INLINE Class ContextControllerClass() &#123; static Class cls; if (!cls) &#123; cls = [[[WKWebView new] valueForKey:@\"browsingContextController\"] class]; &#125; return cls;&#125;FOUNDATION_STATIC_INLINE SEL RegisterSchemeSelector() &#123; return NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");&#125;FOUNDATION_STATIC_INLINE SEL UnregisterSchemeSelector() &#123; return NSSelectorFromString(@\"unregisterSchemeForCustomProtocol:\");&#125;@implementation NSURLProtocol (WebKitExt)+ (void)wk_registerScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = RegisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125;+ (void)wk_unregisterScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = UnregisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125; 好了,现在UIWebView与WKWebView 都已经支持自定义NSURLProtocol了;我们创建一个类CLURLProtocol 继承自NSURLProtocol下面这几个方法必须实现 +(BOOL)canInitWithRequest:(NSURLRequest )request;+(NSURLRequest )canonicalRequestForRequest:(NSURLRequest *)request;-(void)stopLoading;-(void)startLoading; 这里不过多废话了 直接上代码123456789101112131415161718192021222324+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; /** 判断是否启用SD_WEBP 并且图片格式为webp 如果为YES 则标记请求需要自行处理并且防止无限循环 为NO则不处理 */ BOOL useCustomUrlProtocol = NO; NSString *urlString = request.URL.absoluteString; if (!SD_WEBP || ([urlString.pathExtension compare:@\"webp\"] != NSOrderedSame)) &#123; useCustomUrlProtocol = NO; &#125;else &#123; //防止无限循环 if ([NSURLProtocol propertyForKey:CLProtocolKey inRequest:request] == nil) &#123; useCustomUrlProtocol = YES; &#125;else &#123; useCustomUrlProtocol = NO; &#125; &#125; return useCustomUrlProtocol;&#125;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; return request;&#125;- (void)stopLoading&#123; //将截获的请求使用NSURLConnection | NSURLSession 获取数据 这里使用的是NSURLConnection&#125; 我们在创建一个WebV继承自UIViewController 用来展示webView12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; self.automaticallyAdjustsScrollViewInsets = NO; if ([self.webView isKindOfClass:[WKWebView class]]) &#123; //WKWebView 注册自定义 NSURLProtocol [NSURLProtocol registerClass:NSClassFromString(@\"CLURLProtocol\")]; [NSURLProtocol wk_registerScheme:@\"http\"]; [NSURLProtocol wk_registerScheme:@\"https\"]; //发起请求 WKWebView *web = (WKWebView *)self.webView; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://onzbjws3p.bkt.clouddn.com/testForwebpSrc/testWebpForHtml.html\"]]]; &#125;else if ([self.webView isKindOfClass:[UIWebView class]]) &#123; //UIWebView 注册自定义 NSURLProtocol [NSURLProtocol registerClass:NSClassFromString(@\"CLURLProtocol\")]; //发起请求 UIWebView *web = (UIWebView *)self.webView; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://onzbjws3p.bkt.clouddn.com/testForwebpSrc/testWebpForHtml.html\"]]]; &#125; &#125;//因为NSURLProtocol 一旦被注册将会使整个app的request请求都会被拦截 我们这里只在进入WebVC时向系统注册,退出WebVC时取消注册 具体时机请自行决定- (void)dealloc&#123; NSLog(@\"WebVC -- dealloc\"); if ([self.webView isKindOfClass:[WKWebView class]]) &#123; [NSURLProtocol unregisterClass:NSClassFromString(@\"CLURLProtocol\")]; [NSURLProtocol wk_unregisterScheme:@\"http\"]; [NSURLProtocol wk_unregisterScheme:@\"https\"]; &#125;else if ([self.webView isKindOfClass:[UIWebView class]]) &#123; [NSURLProtocol unregisterClass:NSClassFromString(@\"CLURLProtocol\")]; &#125;&#125; 到此为止UIWebView/WKWebView 均已支持加载webp格式图片效果如图WKWebView 展示效果 UIWebView 展示效果 UIImageView 展示效果 优点: 适合所有网页,可以不用修改网页内部html内容。 缺点: NSURLProtocol 拦截App 的所有请求, 使用时需要根据个人项目情况而定, WKWebView 在post请求时会丢失boay, 目前解决方式为在WKWebView的 开始加载的 代理方法判断是否为post,为post解除注册自定义的NSURLProtocol,为GET请求时注册自定义NSURLProtocol。 实现方式二 通过JavaScript与OC共同完成实现思路:1、向网页内注入JS2、在App 本地开启线程下载图片,下载完成后,将图片转码由 webP—&gt; png—&gt;Base64。3、将 Base64及原图片下载地址一一对应调用JS准备好的方法进行替换。4、将下载后的图片进行缓存,并进行管理。 注意注意:A、图片未真正加载完毕时,网页中图片为了体验好可以添加默认占位图片。B、图片显示成功前应该保持网页布局不调整,需要由JS预先设置好布局。C、图片在本地的缓存需要管理。 获取网页img标签的js代码123456789101112function talentcGetAllImageSrc ()&#123; var imagesList = document.images; var srcList = []; var patt1 = new RegExp(\"\\.webp$\"); for(var i = 0; i &lt; imagesList.length; i++) &#123; if(patt1.test(imagesList[i].src)) &#123; srcList.push(imagesList[i].src); &#125; &#125; return JSON.stringify(srcList);&#125;; 替换网页img标签的js代码1234567function talentcReplaceWebPImg (src, localPath)&#123; var elementList = document.querySelectorAll('img[src=\"'+src+'\"]'); for(var element in elementList) &#123; elementList[element].src = localPath; &#125;&#125; 优点:对于UIWebview 与 WKWebView是通用不需要特殊处理,也不会拦截App中的请求。 缺点:对于展示的第三方网页需要根据网页做一些适配, 例如部分网页展示图片使用的div的background-image。 UIWebView 展示效果 WKWebView 展示效果全文终 本文demo 下载","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"WebView","slug":"WebView","permalink":"http://yoursite.com/tags/WebView/"},{"name":"WebP","slug":"WebP","permalink":"http://yoursite.com/tags/WebP/"}]},{"title":"UIlabel设置行间距,字间距","date":"2017-04-10T06:49:21.000Z","path":"2017/04/10/labelSetAttribute/","text":"在iOS开发中经常会用到UIlabel来展示一些文字性的内容，但是默认的文字排版会觉得有些挤，为了更美观也更易于阅读我们可以通过某些方法将UIlabel的行间距和字间距按照需要调节。代码如下： 12345678910111213141516- (void)setLabelSpace:(UILabel *)label withValue:(NSString *)str withFont:(UIFont *)font&#123; NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init]; paraStyle.lineBreakMode = NSLineBreakByCharWrapping; paraStyle.alignment = NSTextAlignmentLeft; paraStyle.lineSpacing = UILABEL_LINE_SPACE; //设置行间距 paraStyle.hyphenationFactor = 1.0; paraStyle.firstLineHeadIndent = 0.0; paraStyle.paragraphSpacingBefore = 0.0; paraStyle.headIndent = 0; paraStyle.tailIndent = 0; //设置字间距 NSKernAttributeName:@1.5f NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.5f&#125;; NSAttributedString *attributeStr = [[NSAttributedString alloc] initWithString:str attributes:dic]; label.attributedText = attributeStr;&#125; 1234567891011121314151617//计算UILabel的高度（带有行间距的情况）-(CGFloat)getSpaceLabelHeight:(NSString*)str withFont:(UIFont*)font withWidth:(CGFloat)width &#123; NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init]; paraStyle.lineBreakMode = NSLineBreakByCharWrapping; paraStyle.alignment = NSTextAlignmentLeft; paraStyle.lineSpacing = UILABEL_LINE_SPACE; paraStyle.hyphenationFactor = 1.0; paraStyle.firstLineHeadIndent = 0.0; paraStyle.paragraphSpacingBefore = 0.0; paraStyle.headIndent = 0; paraStyle.tailIndent = 0; NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.5f&#125;; CGSize size = [str boundingRectWithSize:CGSizeMake(width, HEIGHT) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size; return size.height;&#125;","tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"},{"name":"UILabel","slug":"UILabel","permalink":"http://yoursite.com/tags/UILabel/"}]}]