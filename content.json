[{"title":"Swift学习之路--Swift基础(十二)","date":"2017-11-16T10:05:08.000Z","path":"2017/11/16/SwiftIntroduceTwelveth/","text":"作者刘文涛转载请注明出处 属性（Properties）属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。 存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接作用与类型本身，这种属性成为类型属性。 另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。 存储属性简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字 var 定义），也可以用常量存储属性（用关键字 let 定义）。 可以在定义存储属性的时候指定默认值，也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。 ####常量结构体的存储属性 如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行。 这种行为是由于结构体属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。 属于引用类型的类则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。 延迟存储属性延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标示一个延迟存储属性。 注意：必须将延迟存储属性声明成变量（使用关键字 var ），因为属性的初始值可能在实例构造完之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。 延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。 下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码： 123456789101112131415161718class DataImporter &#123; /* DataImporter 是一个负责将外部文件中的数据导入的类。 这个类的初始化会消耗不少时间。 */ var fileName = &quot;data.text&quot; // 这里会提供数据导入功能&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() //这里会提供数据管理功能&#125;let manager = DataManager ()manager.data.append(&quot;Some data&quot;)manager.data.append(&quot;Some more data&quot;)// DataImporter 实例的 importer 属性还没有被创建 DataManager 类包含了一个名为 data的存储属性，初始值是一个空的字符串（String）数组。。这里没有给出全部代码，只需知道 DataManager 类的目的是管理和提供对这个字符串数组的访问即可。 DataManager 的一个功能是从文件导入数据，该功能由 DataImporter 类提供，DataImporter 完成初始化需要消耗不少时间：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。 DataManager 管理数据时也可能不从文件中导入数据。所以当 DataManager 的实例被创建时，没必要创建一个DataImporter 的实例，更明智的做法是第一次用到 DataImporter 的时候才去创建它。 由于使用了 lazy，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName时： 123print(manager.importer.fileName)// DataImporter 实例的 importer 属性现在被创建了// 输出 &quot;data.txt” 注意：如果一个被标记为 lazy 的属性在没有初始化就同时被多个线程访问，则无法保证该属性只会被初始化一次。 计算属性除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。 1234567891011121314151617181920212223242526272829struct Point &#123; var x = 0.0, y = 0.0 &#125;struct Size &#123; var width = 0.0, height = 0.0 &#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point&#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set &#123; origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) &#125; &#125; &#125;var square = Rect(origin:Point(x:0.0, y:0.0),size:Size(width:10.0,height:10.0))let initialSquareCenter = square.centersquare.center = Point(x:15.0, y:15.0)print(&quot;square.origin is now at (\\(square.origin.x), \\(square.origin.y))&quot;)// 打印 &quot;square.origin is now at (10.0, 10.0)” square 的 center 属性可以通过点运算符（square.center）来访问，这会调用该属性的getter来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的 Point 来表示 square 的中心点。如代码所示，它正确返回了中心点 (5,5)。 center 属性之后被设置了一个新的值（15，15），设置属性 center 的值会调用它的 setter 来修饰属性 origin 的 x 和 y 的值，从而实现移动正方形到新的位置。 简化 setter 声明如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue 。 只读计算属性只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。 注意：必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。 let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。 只读计算属性的声明可以去掉 get 关键字和花括号： 123let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print(&quot;the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)&quot;)// 打印 &quot;the volume of fourByFiveByTwo is 40.0&quot; 属性观察器属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。 可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和影响值的变化。 可以为属性添加如下的一个或全部观察器：• willSet 在新的值被设置之前调用• didSet 在新的值被设置之后立即调用 willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。 同样的，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue 。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。 下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 stepCounter的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。 1234567891011121314151617181920class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newTotalSteps) &#123; print(&quot;About to set totalSteps to \\(newTotalSteps)&quot;) &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print(&quot;Added \\(totalSteps - oldValue) steps&quot;) &#125; &#125; &#125; &#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// About to set totalSteps to 200// Added 200 stepsstepCounter.totalSteps = 360// About to set totalSteps to 360// Added 160 stepsstepCounter.totalSteps = 896// About to set totalSteps to 896// Added 536 steps stepCounter 类定义了一个 Int 类型的属性 totalSteps ，它是一个存储属性，包含 willSet 和 didSet 观察器。 当 totalSteps 被设置新值的时候，他的 willSet 和 didSet 观察器会被调用，即使新值和当前值完全相同也会被调用。 例子中的 willSet 观察器将表示新值的参数自定义为 newTotalSteps ，这个观察器只是简单的将新的值输出。didSet 观察器在 totalSteps 的值改变后被调用，它把新值和旧值进行对比，didSet 没有为旧值提供自定义名称，所以默认值 oldValue 表示旧值的参数名。 注意：如果将属性通过 in-out 方式传入函数，willSet 和 didSet也会调用。这是因为 in-out 参数采用了拷入拷出模式:即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。 全局变量和局部变量计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。 前面的章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。 另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。 注意：全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记 lazy 修饰符。局部范围的常量或变量从不延迟计算。 类型属性实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。 也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。 类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就行C语言中的静态常量），或者所有实例都能访问的一个变量（就行C语言中的静态变量）。 存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。 注意：跟实例的存储属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。 类型属性语法在 C 或 OC 中，与某个类型关联的静态常量和静态变量，是作为全局静态变量定义的。但在Swift中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。 使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法: 12345678910111213141516171819202122struct SomeStructure &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 注意：例子中的计算型类型属性是只读的，但是也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。 获取和设置类型属性的值跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如： 12345678910print(SomeStructure.storedTypeProperty)// 打印 &quot;Some value.&quot;SomeStructure.storedTypeProperty = &quot;Another value.&quot;print(SomeStructure.storedTypeProperty)// 打印 &quot;Another value.&quot;print(SomeEnumeration.computedTypeProperty)// 打印 &quot;6&quot;print(SomeClass.computedTypeProperty)// 打印 &quot;27&quot;","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(十一)","date":"2017-11-15T09:35:08.000Z","path":"2017/11/15/SwiftIntroduceEleventh/","text":"作者刘文涛转载请注明出处 类和结构体类和结构体是人们构建代码所用的一种通用且灵活的构造体。我们可以使用完全相同的语法规则来为类和结构体定义属性（常量、变量）和添加方法，从而扩展类和结构体的功能。与其他编程语言不同的是，Swift并不要求你为自定义类和结构去创建独立的接口和实现文件。你所需要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。 注意：通常一个类的实例被称为对象。然而在Swift中，类和结构体的关系要比在其他语言中更加密切，本章中所讨论的大部分功能都可以用在类和结构体上。 类和结构体对比Swift 中类和结构体有很多共同点，共同之处在于：• 定义属性用于存储值• 定义方法用于提供功能• 定义下标操作使得可以通过下标语法来访问实例所包含的值• 定义构造器用于生产初始值• 通过扩展以增加默认实现的功能• 实现协议以提供某种标准功能 与结构体相比，类还有如下的附近功能：• 继承允许一个类继承另一个类的特征• 类型转换允许在运行时检查和解释一个类实例的类型• 析构器允许一个类实例释放任何其所被分配的资源• 引用计数允许对一个类的多次引用 ####定义语法 类和结构体有着类似的定义方式。我们通过关键字 class和 struct 来分别表示类和结构体，并在一对大括号中定义他们的具体内容： 123456class SomeClass &#123; //在这里定义类&#125;struct SomeStructure &#123; //在这里定义结构体&#125; 注意在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的Swift类型。因此请使用 UpperCamelCase 这种方式来命名（如SomeClass 和 SomeStructure等）,以便符合标准Swift类型的大写命名风格 （如 String， Int 和 Bool）。相反的，请使用 lowerCamelCase 这种方式为属性和方法命名 （如 framerate 和 incrementCount），以便和类型名区分。 以下是定义结构体和定义类的示例： 12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 在上面的示例中我们定义了一个名为 Resolution 的结构体，用来描述一个显示器的像素分辨率。这个结构体包含了两个名为 width 和 height 的存储属性。存储属性是被捆绑和存储在类或结构体中的常量或变量。当这两个属性被初始化为整数 0 的时候，他们会被推断为 Int 类型。 在上面的示例中我们还定义了一个名为 VideoMode的类，用来描述一个视频显示器的特定模式。这个类包含了四个变量存储属性。第一个是 分辨率 ，它被初始化为一个新的 Resolution 结构体的实例，属性类型被推断为 Resolution 。新 VideoMode 实例同时还会初始化其它三个属性，它们分别是，初始值为 false 的 interlaced ，初始值为 0.0 的 frameRate ，以及值为可选 String 的 name 。 name 属性会被自动赋予一个默认值 nil ，意为“没有name 值”，因为它是一个可选类型。 类和结构体实例Resolution 结构体和 VideoMode 类的定义仅描述了什么是Resolution 和 VideoMode。他们并没有描述一个特定的分辨率（resolution）或者视频模式（video mode）。为了描述一个特定的分辨率或者视频模式，我们需要生成一个它们的实例。 生成结构体和类实例的语法非常相似： 12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如 Resolution() 或 VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。 属性访问通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号( . )连接: 12print(&quot;The width of someResolution is \\(someResolution.width)&quot;)//打印 The width of someResolution is 0 在上面的例子中， someResolution.width 引用 someResolution 的 width 属性，返回 width 的初始值 0 。你也可以访问子属性，如 VideoMode 中 Resolution 属性的 width 属性 12print(&quot;The width of someVideoMode is \\(someVideoMode.resolution.width)&quot;)//打印 The width of someVideoMode is 0 你也可以使用点语法为变量属性赋值： 123someVideoMode.resolution.width = 1280print(&quot;The width of someVideoMode is now \\(someVideoMode.resolution.width)&quot;)//打印 The width of someVideoMode is now 1280 注意：与OC 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了 someVideoMode 中 resolution 属性的 width 这个子属性，以上操作并不需要重新为整个 resolution 属性设置新值。 结构体类型的成员逐一构造器 所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中: 1let vga = Resolution(width:640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。 结构体和枚举是值类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。 在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属 性，在代码中传递的时候都会被复制。 请看下面这个示例，其使用了前一个示例中的 Resolution 结构体： 12let hd = Resolution(width: 1920, height: 1080)var cinema = hd 在以上示例中，声明了一个名为hd的常量，其值为一个初始化为全高清视频分辨率(1920 像素宽，1080 像素高)的 Resolution 实例。然后示例中又声明了一个名为 cinema 的变量，并将 hd 赋值给它。因为 Resolution 是一个结构体，所以 cinema 的值其实是 hd 的一个拷贝副本，而不是 hd 本身。尽管 hd 和 cinema 有着相同的宽 (width) 和高 (height) ，但是在幕后它们是两个完全不同的实例。 类是引用类型与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。 请看下面这个示例，其使用了之前定义的 VideoMode 类 12345let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = &quot;1080i&quot;tenEighty.frameRate = 25.0 以上示例中，声明了一个名为 tenEighty 的常量，其引用了一个 VideoMode 类的新实例。在之前的示例中，这个视频模式(video mode)被赋予了HD分辨率( 1920 * 1080 )的一个拷贝(即 hd 实例)。同时设置为 interlaced ，命名为 “1080i” 。最后，其帧率是 25.0 帧每秒。 然后， tenEighty 被赋予名为 alsoTenEighty 的新常量，同时对 alsoTenEighty 的帧率进行修改 12let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0 因为类是引用类型，所以 tenEight 和 alsoTenEight 实际上引用的是相同的 VideoMode 实例。换句话说，它们是同一个实例的两种叫法。 通过查看 tenEighty 的 frameRate 属性，我们会发现它正确的显示了所引用的 VideoMode 实例的新帧率，其值为 30.0 。 需要注意的是 tenEight 和 alsoTenEight 被声明为常量而不是变量。然而你依然可以改变 tenEighty.frameRate 和 alsoTenEighty.frameRate,因为 tenEight 和 alsoTenEight 这两个常量的值并未改变。它们并不 “存储”这个 VideoMode 实例，而仅仅是对 VideoMode 实例的引用。所以，改变的是被引用的 VideoMode 的 frameRate 属性，而不是引用 VideoMode 的常量的值。 恒等运算符因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。(对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。) 如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift内建了两个恒等运算符：• 等价于 （===）• 不等价于 （!==） 运用这两个运算符检测两个常量或者变量是否引用同一个实例 123 print(&quot;tenEighty and alsoTenEighty refer to the same Resolution instance.&quot;)&#125;//打印 tenEighty and alsoTenEighty refer to the same Resolution instance. 请注意，“等价于”(用三个等号表示， === )与“等于”(用两个等号表示， ==)的不同:• “等价于”表示两个类类型(class type)的常量或者变量引用同一个类实例。• “等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。 指针一个引用某个引用类型实例的 Swift 常量或者变量，与 C 语言中的指针类似，但是并不直接指向某个内存地址，也不要求你是用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。 类和结构体的选择在你的代码中，你可以使用类和结构体来定义你的自定义数据类型。 然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者使用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体:• 该数据结构的主要目的是用来封装少量相关简单数据值。• 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。• 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。• 该数据结构不需要去继承另一个既有类型的属性或者行为。举例来说，以下情境中适合使用结构体:• 几何形状的大小，封装一个 width 属性和 height 属性，两者均为 Double 类型。• 一定范围内的路径，封装一个 start 属性和 length 属性，两者均为 Int 类型。• 三维坐标系内一点，封装 x ， y 和 z 属性，三者均为 Double 类型。在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。 字符串、数组和字典类型的赋值与复制行为Swift 中，许多基本类型，诸如 String,Array 和 Dictionary 类型均以结构体的形式实现。这意味着被赋值给信的常量或者变量，或者被传入函数或方法中时，它们的值会被拷贝。 OC 中 NSString ， NSArray 和 NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 注意 以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Sw ift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回 避赋值来保证性能最优化。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(十)","date":"2017-11-13T09:05:08.000Z","path":"2017/11/13/SwiftIntroduceTenth/","text":"作者刘文涛转载请注明出处 枚举(Enumerations)枚举为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。如果你熟悉 C 语言，你会知道在 C 语言中，枚举会为一组整型值分配相关联的名称。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值(称为“原始”值)，则该值的类型可以是字符串，字符，或是一个整型值或浮点数。此外，枚举成员可以指定任意类型的关联值存储到枚举成员中，就像其他语言中的联合体(unions)和变体(variants)。你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。在 Swift 中，枚举类型是一等(first-class)类型。它们采用了很多在传统上只被类(class)所支持的特性，例如计算属性(computed properties)，用于提供枚举值的附加信息，实例方法(instance methods)，用于提供和枚举值相关联的功能。枚举也可以定义构造函数(initializers)来提供一个初始值;可以在原始实现的基础上扩展它们的功能;还可以遵循协议(protocols)来提供标准的功能。 枚举语法使用 enum 关键字来创建枚举并且把它们的整个定义放在一对大括号内：123456789enum SomeEnumeration &#123; //枚举定义放在这里&#125;enum CompassPoint &#123; case north case south case east case west&#125; 枚举中定义的值是这个枚举的成员值（或成员）。你可以使用 case 关键字来定义一个新的枚举成员值。注意：与 C 和 OC 不同，Swift的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的 CompassPoint 例子中，north，south，east 不会被隐式的赋值为0，1，2.相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的 CompassPoint 类型。多个成员值可以出现在同一行上，用逗号隔开： 123enum Planet &#123; case mercury,venus,earth,mars&#125; 每个枚举都定义了一个全新的类型 。像 Swift 中其他类型一样，它们的名字(例如 CompassPoint 和 Planet )应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解: 1var directionToHead = CompassPoint.west directionToHead 的类型可以在它被 CompassPoint 的某个值初始化时推断出来。一旦 directionToHead 被声明为CompassPoint 类型，你可以使用更简短的点语法将其设置为另一个 CompassPoint 的值: 1directionToHead = .east 当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种写法让代码具有更好的可读性。 使用 Swift 语句匹配枚举值你可以使用 switch 语句匹配单个枚举值: 1directionToHead = .south switch directionToHead &#123; case .north: print(&quot;Lots of planets have a north&quot;) case .south: print(&quot;Watch out for penguins&quot;) case .east: print(&quot;Where the sun rises&quot;) case .west: print(&quot;Where the skies are blue&quot;) &#125; // 打印 &quot;Watch out for penguins” 正如在控制流中介绍的那样，在判断一个枚举类型的值时，switch 语句必须穷举所有情况。如果忽略了.west这种情况，上面那段代码将无法通过编译，因为它没有考虑到CompassPoint的全部成员。强制穷举确保了枚举不会被意外遗漏。当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员： 1let somePlanet = Planet.earth switch somePlanet &#123; case .earth: print(&quot;Mostly harmless&quot;) default: print(&quot;Not a safe place for humans&quot;) &#125; // 打印 &quot;Mostly harmless” 关联值上一小节的例子演示了如何定义和分类枚举的成员。你可以为Planet.earth设置一个常量或者变量，并在赋值之后查看这个值。然而，有时候能够把其他类型的关联值和成员值一起存储起来会很有用。这能让你连同成员值一起存储额外的自定义信息，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值。你可以定义Swift枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。 原始值作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。这是一个使用 ASCII 码作为原始值的枚举： 12345enum ASCIIControlCharacter: Character &#123; case tab = &quot;\\t&quot; case lineFeed = &quot;\\n&quot; case carriageReturn = &quot;\\r&quot;&#125; 枚举类型 ASCIIControlCharacter 的原始值类型被定义为 Character，并设置了一些比较常见的 ASCII 控制字符。原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。 注意原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或者变量时才设置的值，枚举成员的关联值可以变化。 原始值的隐式赋值在使用原始值为整数或者字符串类型的枚举时，不需要显示地为每一个枚举成员设置原始值，Swift将会自动为你赋值。例如，当使用整数作为原始值时，隐式赋值的值依次递增 1 。如果第一个枚举成员没有设置原始值，其原始值将为 0。下面的枚举是对之前 PLanet 这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序： 123enum Planet: Int &#123; case mercury = 1, venus, earth, mars, jupiter,saturn, uranus, neptune&#125; 在上面的例子中，Planet.mercury的显式原始值为1，Planet.venus 的隐式原始值为 2，依次类推。 当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。下面的例子是 CompassPoint 枚举的细化，使用字符串类型的原始值来表示各个方向的名称: 123enum CompassPoint: String &#123; case north, south, east, west&#125; 上面例子中，CompassPoint,south 拥有隐式原始值 south，一次类推。使用枚举成员的 rawValue 属性可以访问该枚举成员的原始值： 1234let earthsOrder = Planet.earth.rawValue // earthsOrder 值为 3let sunsetDirection = CompassPoint.west.rawValue // sunsetDirection 值为 &quot;west&quot; 使用原始值初始化枚举实例如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做 rawValue 的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。这个例子利用原始值 7 创建枚举成员 uranus ：12let possiblePlanet = Planet(rawValue: 7)// possiblePlanet 类型为 Planet? 值为 Planet.uranus 然而，并非所有的Int值都可以找到一个匹配的行星。因此，原始值构造器总是返回一个可选的枚举成员。在上面的例子中，possiblePlanet 是 Planet? 类型，或者说“可选的 Planet ”。 注意：原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。 递归枚举递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以再枚举成员前加上 indirect 来表示该成员可递归。 例如下面的例子中，枚举类型存储了简单的算术表达式： 12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case muitiplication(ArithmeticExpression, ArithmeticExpression)&#125; 你也可以在枚举类型开头加上 indirect关键字来表面它的所有成员都是可递归的： 12345indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case muitiplication(ArithmeticExpression, ArithmeticExpression)&#125; 上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员 addition 和 multiplication 的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式 (5 + 4) * 2 ，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用 ArithmeticExpression 这个递归枚举创建表达式 (5 + 4) * 2 1234let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)let product = ArithmeticExpression.muitiplication(sum, ArithmeticExpression.number(2)) 要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数： 12345678910111213func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition (left, right): return evaluate(left) + evaluate(right) case let .muitiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125;print(evaluate(product))//打印 18 该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(九)","date":"2017-11-07T02:39:58.000Z","path":"2017/11/07/SwiftIntroduceNighth/","text":"作者刘文涛转载请注明出处 闭包(Closures)闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（block）以及其他一些编程语言中的匿名函数比较相似。闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。Swift会为你管理在捕获过程中涉及到的所有内存操作。 在函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：• 全局函数是一个有名字但不会捕获任何值的闭包• 嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包• 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：• 利用上下文推断参数和返回值类型• 隐式返回单表达式闭包，即单表达式闭包可以忽略 return 关键字• 参数名称缩写• 尾随闭包语法 闭包表达式闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sorted(by:) 方法定义和语法优化的方式。每一次迭代都用更简洁的方式描述了相同的功能。 sorted 方法 Swift 标准库提供了名为 sorted(by:) 的方法，它会根据你所提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成， sorted(by:) 方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被 sorted(by:) 方法修改。 123456let counts = [12,3,4,56,6]func backward(_ s1: Int, _ s2: Int) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedCounts = counts.sorted(by: backward)// reversedCounts 为 [56, 12, 6, 4, 3] 然而，以这种方式来编写一个实际上很简单的表达式 （a&gt;b），确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好的构造一个内联排序闭包。 闭包表达式语法闭包表达式语法有如下的一般形式： 123&#123;(parameters) -&gt; returnType in statements&#125; 闭包表达式参数 可以是 in-out 参数，但不能设定默认值。也可以使用具名的可变参数。元组也可以作为参数和返回值。下面的例子展示了之前 backward(_:_:) 函数对应的闭包表达式版本的代码: 123var reversedCounts = counts.sorted(by: &#123; (s1: Int, s2: Int) -&gt; Bool in return s1 &gt; s2&#125;) 需要注意的是内联闭包参数和返回值类型声明与 backward(_:_:) 函数类型声明相同。在这两种方式中，都写成了 (s1: Int, s2: Int) -&gt; Bool 。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。闭包的函数体部分由关键字 in 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码: 1var reversedCounts = counts.sorted(by: &#123; (s1: Int, s2: Int) -&gt; Bool in return s1 &gt; s2 &#125;) 该例中 sorted(by:) 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。 根据上下文推断类型因为排序闭包函数是作为 sorted(by:) 方法的参数传入的，Swift可推断其参数和返回值类型。 sorted(by:) 方法被一个Int数组调用，因此其参数必须是 ( Int, Int) -&gt; Bool 类型的函数。这意味着 ( Int, Int) 和 Bool 类型并不需要作为闭包表达式定义的一部分，因为所有的类型都可以被正确推断，返回箭头 和围绕在参数周围的括号也可以被省略： 1reversedCounts = counts.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125;) 实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 sorted(by:) 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。 单表达式闭包隐式返回单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为： 1reversedCounts = counts.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125;) 在这个例子中， sorted(by:) 方法的参数类型明确了闭包必须返回一个 Bool 类型值。因为闭包函数体只包含了一个单一表达式 （s1 &gt; s2），该表达式返回 Bool 类型值，因此这里没有歧义，return 关键字可以省略。 参数名称缩写Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 $0 , $1, $2 来顺序调用闭包的参数，以此类推。如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。 in 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成： 1reversedCounts = counts.sorted(by: &#123; $0 &gt; $1 &#125;) 在这个例子中，$0 , $1表示闭包中第一个和第二个 Int 类型的参数。 运算符方法实际上还有一种更简短的方式来编写上面例子中的闭包表达式。你可以简单地传递一个大于号，Swift 可以自动推断出 你想使用大于号的Int函数实现: 1reversedCounts = counts.sorted(by: &gt;) 值捕获闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。Swift中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。 123456789func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer &#125; incrementer() 函数并没有任何参数，但是在函数体内访问了 runningTotal 和 amount 变量。这是因为它从外围函数捕获了 runningTotal 和 amount 变量的引用。捕获引用保证了 runningTotal 和 amount 变量在调用完makeIncrementer 后不会消失，并且保证了在下一次执行 incrementer 函数时，runningTotal 依旧存在。 注意：为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift可能会改为捕获并保存一份对值的拷贝。Swift也会负责被捕获变量的所有内存管理工作，包括释放不在需要的变量。 下面是一个使用 makeIncrementor 的例子:该例子定义了一个叫做 incrementByTen 的常量，该常量指向一个每次调用会将其 runningTotal 变量增加 10 的 incrementor 函数。调用这个函数多次可以得到以下结果: 12345let incrementByTen = makeIncrementor(forIncrement: 10)incrementByTen()//返回值为10incrementByTen()//返回值为20 如果你创建了另一个 incrementor，它会有属于自己的引用，指向一个全新、独立的 runningTotal 变量： 123let incrementBySeven = makeIncrementor(forIncrement: 7);incrementBySeven()//返回值为7 再次调用原来的 incrementByTen 会继续增加它自己的runningTotal 变量，该变量和 incrementBySeven 中捕获的变量没有任何联系: 12incrementByTen()//返回值为30 注意：如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift使用捕获列表来打破这种循环强引用。 闭包是引用类型上面的例子中， incrementByTen 和 incrementBySeven 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用 incrementByTen 是一个常量，而并非闭包内容本身。这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包： 123let alsoIncrementByTen = incrementByTenalsoIncrementByTen()//返回值为40 自动闭包自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。 我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。 123456789101112var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]print(customersInLine.count)//打印 5let customerProvider = &#123;customersInLine.remove(at: 0)&#125;print(customersInLine.count)//打印 5print(&quot;Now serving \\(customerProvider())&quot;)//打印 Now serving Chrisprint(customersInLine.count)//打印 4 尽管在闭包的代码中，customersInLine 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意 customerProvider 的类型不是 String ，而是 () -&gt; String ，一个没有参数且返回值为 String 的函数。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(八)","date":"2017-10-25T07:39:58.000Z","path":"2017/10/25/SwiftIntroduceEighth/","text":"作者刘文涛转载请注明出处 函数(Functions)函数是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候“调用”这个函数来完成任务。Swift统一的函数语法非常灵活，可以用来表示任何函数，包括从最简单的没有参数名字的C风格函数，到复杂的带局部和外部参数名的Objective-C风格函数。参数可以提供默认值，以简化函数调用。参数也可以即当做传入参数，也当做传出参数，也就是说，一旦函数执行结束，传入的参数值将被修改。 函数的定义与调用当你定义一个函数时，你可以定义一个或多个有名字的类型的值，作为函数的输入，称为参数，也可以定义某种类型的值作为函数执行结束时的输出，称为返回类型。每个函数有个函数名，用来描述函数执行的任务。要使用一个函数时，用函数名来调用这个函数，并传给它匹配的输入值（称作 实参）。函数的实参必须与函数参数表里参数的顺序一致。 123456func greet(person: String) -&gt; String &#123; let greeting = &quot;Hello,&quot; + person + &quot;!&quot; return greeting&#125;print(greet(person: &quot;Anna&quot;))//输出 Hello,Anna! 所有的这些信息汇总起来成为函数的定义，并且 func 作为前缀。指定函数返回类型时，用返回箭头 -&gt; 后跟返回类型的名称的方式来表示。该定义描述了函数的功能，它期望接收什么作为参数和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用。 函数参数与返回值函数参数与返回值在 Swift 中非常的灵活。你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。 无参数函数函数可以没有参数。下面这个函数就是一个无参数函数，当被调用时，它返回固定的 String 消息： 12345func sayHellloWorld() -&gt; String &#123; return &quot;hello, world&quot;&#125;print(sayHellloWorld())// 输出hello, world 尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。 多参数函数函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。 1234567891011121314func greetAgain(person: String) -&gt; String &#123; return &quot;Hello again, &quot; + person + &quot;!&quot;&#125;print(greetAgain(person: &quot;Anna&quot;))func greet(person: String, alredayGreeted: Bool) -&gt; String&#123; if alredayGreeted &#123; return greetAgain(person: person) &#125;else &#123; return greet(person: person ,alredayGreeted: alredayGreeted) &#125;&#125;print(greet(person: &quot;Tim&quot;, alredayGreeted: true))//输出Hello again, Tim! 你可以通过心思括号内使用逗号分隔来传递一个 String 参数值和一个标识为 alredayGreeted 的Bool值，来调用函数greet(person:alreadyGreeted:)。注意这个函数和上面的greet(person:) 是不同的。 无返回值函数函数可以没有返回值。下面是 greet(person:)函数的另一个版本，这个函数直接打印一个String值，而不是返回它： 1234func greet(person: String) &#123; print(&quot;Hello, \\(person)&quot;)&#125;greet (person: &quot;Dave&quot;) 因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头和返回类型。被调用时，一个函数的返回值可以被忽略： 1 func printAndCount(string: String) -&gt; Int &#123; print(string) return string.characters.count &#125; func printWithoutCounting(string: String) &#123; let _ = printAndCount(string: string) &#125; printAndCount(string: &quot;hello, world&quot;) // 打印 &quot;hello, world&quot; 并且返回值 12 printWithoutCounting(string: &quot;hello, world&quot;) // 打印 &quot;hello, world&quot; 但是没有返回任何值 注意：返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译时错误。 多重返回值函数你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。下例中定义了一个名为 minMax(array:) 的函数，作用是在一个 Int 类型的数组中找出最小值与最大值。123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int)&#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125;else if value &gt; currentMax&#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 因为元组的成员值已被命名，因此可以通过 . 语法来检索找到最小值与最大值： 123let bounds = minMax(array: [10,30,2,45,23])print(&quot;min is \\(bounds.min) max is \\(bounds.max)&quot;)//输出 min is 2 max is 45 需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。 可选元组返回类型如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用可选的（optional）元组返回类型反映整个元组可以是nil的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如(Int， Int)? 或 (String, Int, Bool)?注意 可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的，可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。前面的 minMax(array:) 函数返回了一个包含两个 Int 值的元组。但是函数不会对传入的数组执行任何安全检查，如果 array 参数是一个空数组，如上定义的 minMax(array:) 在试图访问 array[0] 时会触发一个运行时错误。为了安全地处理这个空数组问题，将 minMax(array:) 函数改写为使用可选元组返回类型，并且当数组为空时返回 nil： 123456789101112131415func minMax(array: [Int]) -&gt; (min: Int, max: Int)?&#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125;else if value &gt; currentMax&#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 你可以使用可选绑定来检查 minMax(array:) 函数返回的是一个存在的元组值还是 nil： 1234if let bounds = minMax(array: [10,30,2,45,23]) &#123; print(&quot;min is \\(bounds.min) max is \\(bounds.max)&quot;) //输出 min is 2 max is 45&#125; 函数参数标签和参数名称每个函数参数都有一个参数标签以及一个参数名称。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情况下，函数参数使用参数名称来作为他们的参数标签。所有的参数都必须有一个独一无二的名字。虽然多个参数拥有同样的参数标签是可能的，但是一个唯一的函数标签能够使你的代码更具可读性。 指定参数标签你可以在函数名称前指定它的参数标签，中间以空格分隔： 123func someFunction(argumentLabel parameterName: Int)&#123; //在函数体内，parameterName 代表参数值&#125; 这个版本的 greet(person:) 函数，接收一个人的名字和他的家乡，并返回一句问候： 12345func greet(person: String, from hometown: String) -&gt; String&#123; return &quot;Hello \\(person)! Glad you could visit from \\(hometown)&quot;&#125;print(greet(person: &quot;Bill&quot;, from: &quot;China&quot;))// 输出 Hello Bill! Glad you could visit from China 参数标签的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。 忽略参数标签如果你不希望为某个参数添加一个标签，可以使用一个下划线（_）来代替一个明确的参数标签。 1234func someFunction(_ firstPName: Int, secondPName: Int)&#123; //在函数体内，firstPName和secondPName代表参数中的第一个和第二个参数值&#125;someFunction(1, secondPName: 2); 如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。 默认参数值你可以再函数体中通过给参数赋值来为任意一个参数定义默认值。当默认值被定义后，调用这个函数时可以忽略这个参数。 12345func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12)&#123; //如果你在调用时候不传第二个参数，parameterWithDefault 默认值为12会传入到函数体中。&#125;someFunction(parameterWithoutDefault: 4); //parameterWithDefault = 12someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6); //parameterWithDefault = 6 将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。 可变参数一个可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型后面加入（…）的方式来定义可变参数。可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 numbers 的 Double…型可变参数，在函数体内可以当做一个叫 numbers 的 [Double] 型的数组常量。下面的这个函数用来计算一组任意长度数字的 算术平均值： 12345678910func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total/Double(numbers.count) &#125;arithmeticMean(1,3,4,2,5,6)// 返回 3.5 是这6个数的平均数 注意：一个函数最多只能拥有一个可变参数。 输入输出参数函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误的更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数。定义一个输入输出参数时，在参数定义前加 inout 关键字。一个 输入输出参数 有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。你只能传递变量给输入输出参数。你不能传入常量或者字面量，因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加 &amp; 符，表示这个值可以被函数修改。注意：输入输出参数不能有默认值，而且可变参数不能用 inout 标记。下例中，swapTwoInts(_:_:) 函数有两个分别叫做 a 和 b 的输入输出参数： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoInts(_:_:)函数简单的交换 a 和 b 的值。该函数先将 a 的值存到一个临时常量 temporaryA 中，然后将 b 的值赋给 a ，最后将 temporaryA 赋值给 b。你可以用两个 Int 型的变量来调用 swapTwoInts(_:_:) 。需要注意的是，someInt 和 anotherInt 在传入 swapTwoInts(_:_:) 函数前，都加了 &amp; 的前缀: 12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \\(someInt), and anotherInt is now \\(anotherInt)&quot;)// 输出 someInt is now 107, and anotherInt is now 3 注意：输入输出参数和返回值是不一样的。上面的swapTwoInts函数并没有定义任何返回值，但仍然修改了 someInt 和 anotherInt的值。输入输出参数是函数对函数体外产生影响的另一种方式。 函数类型每个函数都有种特定的函数类型，函数的类型由函数的参数类型和返回类型组成。例如： 每个函数都有种特定的函数类型，函数的类型由函数的参数类型和返回类型组成。例如: func addTwoInts(_ a: Int, _ b: Int) -&gt; Int { return a + b } func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int { return a * b } 12345 这个例子中定义了两个简单的数学函数:``addTwoInts`` 和``multiplyTwoInts``。这两个函数都接受两个 ``Int``` 值， 返回一个 ``Int`` 值。 这两个函数的类型是 ``(Int, Int) -&gt; Int`` ，可以解读为“这个函数类型有两个 Int 型的参数并返回一个 Int 型的值。”。 下面是另一个例子，一个没有参数，也没有返回值的函数: func printHelloWorld() &#123; print(&quot;hello, world&quot;) &#125; 这个函数的类型是: ``() -&gt; Void`` ，或者叫“没有参数，并返回 Void 类型的函数”。#### 使用函数类型在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它: var mathFunction: (Int, Int)-&gt; Int = addTwoInts print(&quot;Result \\(mathFunction(2, 3))&quot;) // 输出 Result 5 12有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样： mathFunction = multiplyTwoInts print(&quot;Result \\(mathFunction(2, 3))&quot;) // 输出 Result 6 1就像其他类型一样，当赋值一个函数给常量或变量时，你可以让Swift来推断其函数类型： let anotherMathFunction = addTwoInts // anotherMathFunction被推断为 (Int, Int)-&gt; Int 类型 12345#### 函数类型作为参数类型你可以用 ``(Int, Int)-&gt; Int`` 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果： func printMathResult(_ mathFunction: (Int, Int)-&gt; Int ,_ a: Int, _ b: Int){ print(&quot;Result \\(mathFunction(a, b))&quot;) } printMathResult(addTwoInts, 3, 4) //输出 Result 7 12345678这个例子定义了 ``printMathResult(_:_:_:)`` 函数，它有三个参数：第一个参数叫 mathFunction，类型是 ``(Int, Int) -&gt; Int``，你可以传入任何这种类型的函数；第二个和第三个参数叫 a 和 b ，它们的类型都是 Int ，这两个值作为已给出的函数的输入值。``printMathResult(_:_:_:)`` 函数的作用就是输出另一个适当类型的数学函数的调用结果。他不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得 ``printMathResult(_:_:_:)`` 能以一种类型安全的方式将一部分功能转给调用者实现。#### 函数类型作为返回类型你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头后写一个完整的函数类型。下面的这个例子中定义了两个简单函数，分别是 ``stepForward(_:)`` 和 ``stepBackward(_:)`` 。 ``stepForward(_:)`` 函数返回一个比输入值大 1 的值。``stepBackward(_:)`` 函数返回一个比输入值小 1 的值。这两个函数的类型都是 ``(Int) -&gt; Int`` : func stepForward(_ input: Int) -&gt; Int { return input + 1 } func stepBackward(_ input: Int) -&gt; Int { return input - 1 } 12如下名为 ``chooseStepFunction(backward:)`` 的函数，它的返回类型是 ``(Int) -&gt; Int`` 类型的函数。 ``chooseStepFunction(backward:)`` 根据布尔值 ``backwards`` 来返回 ``stepForward(_:)`` 函数或 ``stepBackward(_:)`` 函数: func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { return backward ? stepBackward : stepForward } 1你现在可以用 ``chooseStepFunction(backward:)`` 来获得两个函数其中的一个: var currentValue = 3 let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0) // moveNearerToZero 现在指向 stepBackward() 函数。 1上面这个例子中计算出从 ``currentValue`` 逐渐接近到0是需要向正数走还是向负数走。``currentValue`` 的初始值是 3 ，这意味着 ``currentValue &gt; 0`` 为真(true)，这将使得 ``chooseStepFunction(_:)`` 返回 ``stepBackward(_:)`` 函数。一个指向返回的函数的引用保存在了 ``moveNearerToZero`` 常量中。 现在， ``moveNearerToZero`` 指向了正确的函数，它可以被用来数到零: while currentValue != 0 { print(&quot;\\(currentValue)...&quot;) currentValue = moveNearerToZero(currentValue) } //输出 //3... //2... //1... 1234567### 嵌套函数到目前为止本章中你所见到的所有函数都叫做全局函数，他们定义在全局域中。你也可以把函数定义在别的函数体中，称作 嵌套函数。默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数(enclosing function)调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。你可以用返回嵌套函数的方式重写 ``chooseStepFunction(backward:)`` 函数: func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { func stepForward(input: Int) -&gt; Int { return input + 1 } func stepBackward(input: Int) -&gt; Int { return input - 1 } return backward ? stepBackward : stepForward } var currentValue = -4 let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0) while currentValue != 0 { print(&quot;\\(currentValue)...&quot;) currentValue = moveNearerToZero(currentValue) } print(&quot;Zero&quot;) // -4... // -3... // -2... // -1... // zero!","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(七)","date":"2017-08-16T05:59:58.000Z","path":"2017/08/16/SwiftIntroduceSeventh/","text":"作者刘文涛转载请注明出处 控制流(Control Flow)Swift 提供了多种流程控制结构，包括可以多次执行任务的 while 循环，基于特定条件选择执行不同代码分支的 if，guard和switch语句，还有控制流程跳转到其他代码位置的break和continue语句。Swift还提供了 for-in 循环，用来更简单地遍历数组，字典，区间（range），字符串和其他序列类型。Swift 的switch语句比C语言中更强大。在C语言中，如果某个case不小心漏写了break，这个case就会贯穿至下一个case，Swift无需写break，所以不会发生这种贯穿的情况。case 还可以匹配很多不同的模式，包括间隔匹配(interval match)，元组(tuple)和转换到特定类型。 switch 语句的 case 中匹配的值可以绑定成临时常量或变量，在case体内使用，也可以用 where 来描述更复杂的匹配条件。 For-In 循环你可以使用 for-in循环来遍历一个集合中的所有元素，例如数字范围、数组中的元素或者字符串中的字符。12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print(&quot;\\(base) to the power of \\(power) is \\(answer)&quot;)//输出 3 to the power of 10 is 59049 这个例子计算 base 这个数的 power 次幂。进行遍历的元素是使用闭区间操作符( … )表示的从 1 到 10 的数字区间。这个计算并不需要知道每一次循环中计数器具体的值，只需要执行了正确的次数即可。下划线符号 _（替代循环中的变量）能够忽略当前值，并且不提供循环遍历时对值的访问。 While 循环while 循环会一直运行一段语句知道条件变成 false 。这类循环适合使用在第一次迭代前，迭代次数未知的情况下。Swift提供两种 while 循环形式：• while循环，每次在循环开始时计算条件是否符合;• repeat-while循环，每次在循环结束时计算条件是否符合。 while循环从计算一个条件开始。如果条件为true，会重复运行一段语句，直到条件变为false。while循环的另外一种形式是repeat-while，它和while的区别是在判断循环条件之前，先执行一次循环的代码块。然后重复循环直到条件为false。Swift语言的 repeat-while 循环和其他语言中的 do-while 循环是类似的。下面是 repeat-while 循环的一般格式：123repeat &#123; statements&#125; while condition 条件语句Swift提供两种类型的条件语句：if 语句和 switch 语句。通常，当条件较为简单且可能的情况很少时，使用 if 语句。而 switch 语句更适用于条件较复杂。有更多排列组合的时候。并且 switch 在需要用到模式匹配(pattern-matching)的情况下会更有用。 ifif 语句最简单的形式就是只包含一个条件，只有该条件为 true 时，才执行相关代码。当然，if 语句允许二选一执行，叫做else从句。也就是当条件为false时，执行else语句。switchswitch语句会尝试把某个值与若干个模式进行匹配。根据第一个匹配成功的模式，switch语句会执行对应的代码。当有可能的情况较多时，通常用switch语句替换if语句。 1234567891011let somePoint = (1,1)switch somePoint &#123;case (0,0): print(&quot;(0, 0) is at the origin&quot;) case (1,0), (0,1): print(&quot;(1, 0) or (0, 1) is at the origin&quot;)default: print(&quot;(1, 1) is at the origin&quot;)&#125; switch 语句必须是完备的。这就是说，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值的情况下，你可以使用默认( default )分支来涵盖其它所有没有对应的值，这个默认分支必须在 switch 语句的最后面。不存在隐式的贯通与 C 和 Objective-C 中的 switch 语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 switch 语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用 break 语句。这使得 switch 语句更安全、更易用，也避免了因忘记写 break 语句而产生的错误。每一个 case 分支都必须包含至少一条语句。为了让单个case同时匹配 a 和 A ，可以将这个两个值组合成一个复合匹配，并且用逗号分开。不像C语言，Swift允许多个case匹配同一个值。但是，如果存在多个匹配，那么只会执行第一个被匹配到的case分支。因此剩下的能够匹配的分支都会被忽视掉。值绑定case 分支允许将匹配的值绑定到一个临时的常量或变量，并且在case分支体内使用 – 这种行为被称为值绑定，因为匹配的值在case分支体内，与临时的常量或变量绑定。下面的例子展示了如何在一个 (Int, Int) 类型的元组中使用值绑定来分类下图中的点(x, y): 12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print(&quot;on the x-axis with an x value of \\(x)&quot;)case (0,let y): print(&quot;on the y-axis with a y value of \\(y)&quot;)case let (x, y): print(&quot;somewhere else at (\\(x), \\(y))&quot;)&#125;//输出 on the x-axis with an x value of 2 请注意，这个 switch 语句不包含默认分支。这是因为最后一个 case —— case let(x, y) 声明了一个可以匹配余下所有值的元组。这使得 switch 语句已经完备了，因此不需要再书写默认分支。wherecase 分支的模式可以使用where语句来判断额外的条件。下面的例子把下图中的点(x, y)进行了分类: 12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print(&quot;(\\(x), \\(y)) is on the line x == y&quot;)case let (x, y) where x == -y : print(&quot;(\\(x), \\(y)) is on the line x == -y&quot;)case let (x, y): print(&quot;(\\(x), \\(y)) is just some arbitrary point&quot;)&#125;// 输出 &quot;(1, -1) is on the line x == -y&quot; 这三个 case 都声明了常量 x 和 y 的占位符，用于临时获取元组 yetAnotherPoint 的两个值。这两个常量被用作 where 语句的一部分，从而创建一个动态的过滤器(filter)。当且仅当 where 语句的条件为 true 时，匹配到的case 分支才会被执行。就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值， switch 语句就已经完备了，因此不需要再书写默认分支。 控制转移语句控制转移语句改变你代码的执行顺序，通过它可以实现代码的跳转。Swift 有五种控制转移语句：• continue• break• fallthrough• return• throw continue 语句告诉一个循环体立刻停止本次循环，重新开始下次循环。就好像在说“本次循环我已经执行完了”，但是不会离开整个循环体。下面的例子把一个小写字符串中的元音字母和空格字符移除，生成一个含义模糊的短句： 123456789101112let puzzleInput = &quot;great minds think alike&quot;var puzzleOutput = &quot;&quot;for character in puzzleInput.characters &#123; switch character &#123; case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;,&quot; &quot;: continue default: puzzleOutput.append(character) &#125;&#125;print(puzzleOutput)//输出 grtmndsthnklk 在上面的代码中，只要匹配到元音字母或者空格字符，就调用continue语句，使本次循环结束，重新开始下次循环。 break 语句会立刻结束整个控制流的执行。当在一个循环体中使用 break 时，会立刻中断循环体的执行，然后跳到表示循环体结束的大括号后的第一行代码。不会再有本次循环的代码在执行，也不会有下次的循环产生。当在一个switch代码块中使用break时，会立即中断该switch代码块的执行，并且跳到表示switch代码块结束的大括号后的第一行代码。这种特性可以被用来匹配或者忽略一个或多个分支。因为 Swift 的 switch 需要包含所有的分支而且不允许有为空的分支，有时为了使你的意图更明显，需要特意匹配或者忽略某个分支。那么当你想忽略某个分支时，可以在该分支内写上 break 语句。当那个分支被匹配到时，分支内的 break 语句立即结束 switch 代码块。 Swift中的switch不会从上一个case分支落入到下一个case分支中。相反，只要第一个匹配到的case分支完成了它需要执行的语句，整个switch代码块完成了它的执行。相比之下，C 语言要求你显式地插入 break 语句 到每个 case 分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的 switch 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。如果你确实需要C风格的贯穿特性，你可以再每个需要该特性的case分支中使用 fallthrough 关键字。 1234567891011let integerToDescribe = 5var description = &quot;The number \\(integerToDescribe) is&quot;switch integerToDescribe &#123;case 2,3,5,7,13,19: description += &quot; a prime number, and also&quot; fallthroughdefault: description += &quot; an integer.&quot;&#125;print(description)//输出 The number 5 is a prime number, and also an integer. 提前退出像if语句一样，guard 的执行取决于一个表达式的布尔值。我们可以使用guard语句来要求条件必须为真时，以执行guard语句后的代码。不同于if语句，一个guard语句总是有一个else从句，如果条件不为真则执行else从句中的代码。 1234567891011121314151617func greet(person:[String : String])&#123; guard let name = person[&quot;name&quot;] else &#123; return &#125; print(&quot;hello \\(name)&quot;) guard let location = person[&quot;location&quot;] else &#123; print(&quot;I hope the weather is nice near you.&quot;) return &#125; print(&quot;I hope the weather is nice in \\(location).&quot;)&#125;greet(person: [&quot;name&quot;: &quot;Jhon&quot;])//输出 hello Jhon//输出 I hope the weather is nice near you.greet(person: [&quot;name&quot;: &quot;Jane&quot;,&quot;location&quot;: &quot;Cupertino&quot;])//输出 hello Jane//输出 I hope the weather is nice in Cupertino. 相比于可以实现同样功能的if语句，按需要使用guard语句会提升我们代码的可读性。它可以使你的代码连贯的被执行而不需要将它包在 else 块中，它可以使你在紧邻条件判断的地方，处理违规的情况。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(六)","date":"2017-07-26T02:29:58.000Z","path":"2017/07/26/SwiftIntroduceSixth/","text":"作者刘文涛转载请注明出处 集合类型（Collection Types）Swift 语言提供 Arrays 、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 Swift 语言中的 Arrays 、Sets 和 Dictionaries 中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。 集合的可变性如果创建一个 Arrays 、Sets 和 Dictionaries 并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把 Arrays 、Sets 和 Dictionaries分配成常量，那么他就是不可变的，他的大小和内容都不能被改变。 注意：在我们不需要改变集合的时候创建不可变集合是很好的实践。如此Swift编译器可以优化我们创建的集合。 数组数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。 数组的简单语法写 Swift 数组应遵循像 Array&lt;Element&gt; 这样的形式，其中Element 是这个数组中唯一允许存在的数据类型。我们也可以使用像[Element]这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。 创建一个空数组我们可以用构造语法来创建一个由特定数据类型构成的空数组： 12var someInts = [Int]()print(&quot;someInts is of type [Int] with \\(someInts.count) items.&quot;) // 打印 &quot;someInts is of type [Int] with 0 items.&quot; 注意，通过构造函数的类型，someInts 的值类型被推断为 [Int]。或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，他的写法很简单： 1234someInts.append(3)// someInts 现在包含一个 Int 值 3someInts = []// someInts 现在是空数组，但是仍然是 [Int] 类型的。 创建一个带有默认值的数组Swift 中的 Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新 数组的数据项数量( count` )和适当类型的初始值(repeating`` )传入数组构造函数: 12var threeDoubles = Array(repeating:0.0, count: 3)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0] 通过两个数组相加创建一个数组我们可以使用加法操作符（+）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来： 1234var fourDoubles = Array(repeating:2.5, count: 4)// fourDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5, 2.5]var sevenDoubles = threeDoubles + fourDoubles// sevenDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5, 2.5] 用数组字面量构造数组我们可以使用数组字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值： 1[value 1, value 2, value 3] 下面这个例子创建了一个叫做 shoppingList 并且存储 String 的数组: 12var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]// shoppingList 已经被构造并且拥有两个初始项。 由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。shoppingList 构造也可以这样写: 1var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] 因为所有数组字面量中的值都是相同的类型，Swift 可以推断出 [String] 是 shoppingList 中变量的正确类型。 访问和修改数组我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。 可以使用数组的只读属性 count 来获取数组中的数据项数量： 12print(&quot;The shopping list contains \\(shoppingList.count) items&quot;)// // 输出 &quot;The shopping list contains 2 items.&quot;(这个数组有2个项) 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0 。 也可使用 append(_:) 方法在数组后面添加新的数据项： 1shoppingList.append(&quot;Flour&quot;) 除此之外，使用加法赋值运算符( += )也可以直接在数组后面添加一个或多个拥有相同类型的数据项： 1shoppingList += [&quot;Baking Powder&quot;] 也可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值直接放在数组名称的方括号中： 12var firstItem = shoppingList[0]// 第一项是 Eggs 我们也可以用下标来改变某个已有索引值对应的数据值： 12shoppingList[0] = &quot;Six Eggs&quot;// shoppingList的第一项现在是 &quot;Six eggs&quot; 而不是 &quot;Eggs&quot; 还可以用下标一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。 1shoppingList[1...3] = [&quot;Bananas&quot;, &quot;Apples&quot;] 调用数组的 insert(_:at:) 方法来在某个具体索引值之前添加数据项： 12shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)// &quot;Maple Syrup&quot; 现在是这个列表中的第一项 类似的我们可以使用 remove(at:) 方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移 除并且返回这个被移除的数据项： 12let mapleSyrup = shoppingList.remove(at: 0)// mapleSyrup 常量的值等于被移除数据项的值 &quot;Maple Syrup&quot; 数据项被移除后数组中的空出项会被自动填补，所以现在索引值为 0 的数据项的值再次等于 &quot;Six eggs&quot; 如果我们只想把数组中的最后一项移除，可以使用 removeLast() 方法而不是 remove(at:) 方法来避免我们需要获取数组的 count 属性。 1let apples = shoppingList.removeLast() 数组的遍历我们可以使用 for-in 循环来遍历所有数组中的数据项： 1for item in shoppingList &#123; print(item) &#125; // Six eggs // Milk // Flour // Baking Powder // Bananas 如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历： 12345 for (index, value) in shoppingList.enumerated() &#123; print(&quot;Item \\(String(index + 1)): \\(value)&quot;)&#125;//Item 1: Six Eggs//Item 2: Bananas 集合 (Sets)集合（set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要是或者希望确保每个元素只出现一次时，可以使用集合而不是数组。 集合类型的哈希值 一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 Int 类型的，相等的对象哈希值必须相同，比如 a==b，因此必须 a.hashValue = b.hashValue。 Swift 的所有基本类型（比如 String，Int，Double和Bool）默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值默认也是可哈希化的。 集合类型语法Swift中的 Set类型被写为 Set&lt;Element&gt;，这里的Element 表示 Set 中允许存储的类型，和数组不同的是，集合没有等价的简化形式。 创建和构造一个空的集合你可以通过构造器语法创建一个特定类型的空集合： 123var letters = Set&lt;Character&gt;()print(&quot;letters is of type Set&lt;Character&gt; with \\(letters.count) items.&quot;)//打印 letters is of type Set&lt;Character&gt; with 0 items. 此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的 Set : 1234letters.insert(&quot;a&quot;)// letters 现在含有1个 Character 类型的值letters = []// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型 用数组字面量创建集合你可以使用数组字面量来构造 合，并且可以使用简化形式写一个或者多个值作为 合元素。 12var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]// favoriteGenres 被构造成含有三个初始值的集合 一个 Set 类型不能从数组字面量中被单独推断出来，因此 Set 类型必须显式声明。然而，由于Swift的类型推断功能，如果你想使用一个数组字面量构造一个 Set 并且该数组字面量中的所有元素类型相同，那么你无须写出 Set 的具体类型。favoriteGenres 的构造形式可以采用简化的方式代替: 1var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] 访问和修改一个集合你可以通过 Set 的属性和方法来访问和修改一个 Set 。为了找出一个 Set 中元素的数量，可以使用其只读属性 count 。 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0。 你可以通过调用 Set 的 insert(_:) 方法来添加一个新元素。 你可以通过调用 Set 的 remove(_:) 方法去删除一个元素，如果该值是该 Set 的一个元素则删除该元素并且返回被删除的元素值，否则如果该 Set 不包含该值，则返回 nil 。另外， Set 中的所有元素可以通过它的 removeAll() 方法删除。 12345678var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]if let removeGenre = favoriteGenres.remove(&quot;Rock&quot;) &#123; print(&quot;\\(removeGenre)? I`m over it&quot;)&#125;else &#123; print(&quot;I never much cared for that.&quot;)&#125;// 打印 &quot;Rock? I&apos;m over it.&quot; 使用 contains(_:) 方法去检查 Set 中是否包含一个特定的值: 123456if favoriteGenres.contains(&quot;Funk&quot;) &#123; print(&quot;I get up on the good foot.&quot;)&#125;else &#123; print(&quot;It&apos;s too funky in here.&quot;)&#125;// 打印 &quot;It&apos;s too funky in here.&quot; 遍历一个集合你可以在一个 for-in 循环中遍历一个 Set中的所有值。 123456for genre in favoriteGenres &#123; print(&quot;\\(genre)&quot;)&#125;//打印 //Hip hop//Classical Swift 的 Set 类型没有确定的顺序，为了按照特定的顺序来遍历一个 Set 中的值可以使用 sorted() 方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符 ‘&lt;’ 对元素进行比较的结果来确定。 12345for genre in favoriteGenres.sorted() &#123; print(&quot;\\(genre)&quot;)&#125;// prints &quot;Classical&quot;// prints &quot;Hip hop&quot; 集合操作你可以高效地完成 Set 的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。 集合基本操作• 使用 intersection(_:) 方法根据两个 合中都包含的值创建的一个新的集合。 • 使用 symmetricDifference(_:) 方法根据在一个集合中但不在两个 合中的值创建一个新的集合。 • 使用 union(_:) 方法根据两个集合的值创建一个新的集合。 • 使用 subtracting(_:) 方法根据不在该集合中的值创建一个新的集合。 123456789101112let oddDigits: Set = [1,3,5,7,9]let evenDigits: Set = [0,2,4,6,8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(singleDigitPrimeNumbers).sorted()//[3, 5, 7]oddDigits.subtracting(singleDigitPrimeNumbers).sorted()//[1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()//[1, 2, 9] 集合成员关系和相等• 使用“是否相等”运算符( == )来判断两个集合是否包含全部相同的值。 • 使用 isSubset(of:) 方法来判断一个集合中的值是否也被包含在另外一个集合中。 • 使用 isSuperset(of:) 方法来判断一个集合中包含另一个集合中所有的值。 • 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。 • 使用 isDisjoint(with:) 方法来判断两个集合是否不含有相同的值(是否没有交集)。 12345678910let houseAnimals: Set = [&quot;?&quot;,&quot;?&quot;]let farmAnimals: Set = [&quot;?&quot;,&quot;?&quot;,&quot;?&quot;,&quot;?&quot;,&quot;?&quot;,&quot;?&quot;]let cityAnimals: Set = [&quot;?&quot;,&quot;?&quot;]houseAnimals.isSubset(of: farmAnimals)//truefarmAnimals.isSuperset(of: cityAnimals)//truefarmAnimals.isDisjoint(with: cityAnimals)//false 字典字典是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key）,键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典。 字典类型简化语法Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义，其中 Key 是字典中键的数据类型， Value 是字典中对应于这些键所存储值的数据类型。我们也可以用 [Key: Value] 这样简化的形式去创建一个字典类型。虽然这两种形式功能上相同，但是后者是首选，并且这本指导书涉及到字典类型时通篇采用后者。 创建一个空字典我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典： 12var namesOfIntegers = Int: Sring// namesOfIntegers是一个空的[Int: String]字典 如果上下文已经提供了类型信息，我们可以使用字典字面量来创建一个空字典，记作：[:] 1234namesOfIntegers[16] = &quot;sixteen&quot;// namesOfIntegers 现在包含一个键值对nameOfIntegers = [:]// namesOfIntegers 又成为了一个空的[Int: String]字典 用字典字面量创建字典我们可以使用字典字面量来构造字典，这和我们刚才介绍过的数组字面量拥有相似语法。字典字面量是一种将一个或多个键值对写作 Dictionary 合的快捷途径。 1var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;] airports 字典被声明为一种[String: String]类型，这意味着这个字典的键和值都是String类型。 访问和修改字典我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。和数组一样，我们可以通过字典的只读属性 count 来获取某个字典的数据项数量。使用布尔属性 isEmpty 作为一个缩写形式去检查 count属性是否为 0。我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值:12airports[&quot;LHR&quot;] = &quot;London&quot;//airports 字典现在有三个数据 我们也可以使用下标语法来改变特定键对应的值：12airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;// &quot;LHR&quot;对应的值 被改为 &quot;London Heathrow 作为另一种下标方法，字典的 updateValue(_:forKey:) 方法可以设置或更新特定键对应的值。在键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的，updateValue(_:forKey:) 这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。updateValue(_:forKey:) 方法会返回对应值的类型的可选值。举例来说:对于存储 String 值的字典，这个函数会 返回一个 String? 或者“可选 String ”类型的值。如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是nil. 1234let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUBv&quot;) &#123; print(&quot;The old value for DUB was (oldValue).&quot;)&#125;// 输出 &quot;The old value for DUB was Dublin.&quot; 我们还可以使用下标语法来通过给某个键对应的值赋值为 nil来从字典里移除一个键值对： 1234airports[&quot;APL&quot;] = &quot;Apple Internation&quot;// &quot;Apple Internation&quot; 不是真的 APL 机场, 删除它airports[&quot;APL&quot;] = nil// APL 现在被移除了 此外，removeValue(forKey: ) 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者没有值的情况下返回nil： 1if let removedValue = airports. removeValue(forKey: &quot;DUB&quot;) &#123; print(&quot;The removed airport&apos;s name is (removedValue).&quot;) &#125; else &#123; print(&quot;The airports dictionary does not contain a value for DUB.&quot;) &#125; // prints &quot;The removed airport&apos;s name is Dublin Airport.&quot; 字典遍历我们可以使用fot-in循环来遍历某个字典中的键值对。每一个字典中的数据项都以 (key, value) 元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组:12345for (airportCode, airportName) in airports &#123; print(&quot;\\(airportCode): \\(airportName)&quot;)&#125;//DUB: Dublin//YYZ: Toronto Pearson 通过访问keys或者values属性，我们也可以遍历字典的键或者值：12345678910for airportCode in airports.keys &#123; print(&quot;Airport code: \\(airportCode)&quot;)&#125;// Airport code: DUB// Airport code: YYZfor airportName in airports.values &#123; print(&quot;Airport name: \\(airportName)&quot;)&#125;// Airport name: Dublin// Airport name: Toronto Pearson Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的keys或values属性使用 sorted()方法。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(五)","date":"2017-07-24T02:59:58.000Z","path":"2017/07/24/SwiftIntroduceFifth/","text":"作者刘文涛转载请注明出处 字符串和字符字符串是例如 &quot;hello world&quot; , &quot;albatross&quot; 这样有序的 Character（字符）类型的值的集合。通过 String 类型来表示。Swift 的 String 和 Character 类型提供了快速和兼容 Unicode 的方式供你的代码使用。创建和操作字符串的语法与 C 语言中字符串操作相似,轻量并且易读。 字符串连接操作只需要简单地通过 + 符号将两个字符串相连即 可。与 Swift 中其他值一样,能否更改字符串的值,取决于其被定义为常量还是变量。你也可以在字符串内插过程中使用字符串插入常量、变量、字面量表达成更长的字符串,这样可以很容易的创建自定义的字符串值,进行展示、存储以及打印。 注意：Swift的 String 类型与 Foundation NSString 类进行了无缝桥接。Foundation 也可以对 String 进行扩展，暴露在 NSString 中定义的方法。这意味着，如果你在 String 中调用这些 NSString 的方法，将不用进行转换。 字符串字面量您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。字符串字面量是由双引号 ( “” ) 包裹着的具 有固定顺序的文本字符 。字符串字面量可以用于为常量和变量提供初始值: 1let someString = &quot;Some String literal Value&quot; 注意 someString 常量通过字符串字面量进行初始化,Swift 会推断该常量为 String 类型。 初始化空字符串要创建一个空字符串作为初始值,可以将空的字符串字面量赋值给变量,也可以初始化一个新的 String 实例: 1var emptyString = &quot;&quot; // 空字符串字面量 var anotherEmptyString = String() // 初始化方法 // 两个字符串均为空并等价。 您可以通过检查其 Bool 类型的 isEmpty 属性来判断该字符串是否为空: 123if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125; 字符串可变性你可以通过将一个字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改： 123456var varString = &quot;Horse&quot;varString += &quot;and carriage&quot;// variableString 现在为 &quot;Horse and carriage&quot;let constantString = &quot;Highlander&quot;constantString += &quot;and another&quot;// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。 注意：在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类（NSString 和 NSMutableString）来指定字符串是否是可修改的。 字符串是值类型Swift 的 String 类型是值类型。如果你创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您独自拥有的。 您可以确信传递的字符串不会被修改，除非你自己去修改它。在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。 使用字符你可以通过 for - in 循环来遍历字符串中的 characters 属性来获取每一个字符的值： 1for character in &quot;Dog!?&quot;.characters &#123; print(character) &#125; // D // o // g // ! // ? 字符串可以通过传递一个值类型为 character 的数组作为自变量来初始化： 12let catCharacters: [character] = [&quot;C&quot;,&quot;a&quot;,&quot;t&quot;,&quot;!&quot;]let catString = String(catCharacters) 连接字符串和字符字符串可以通过加法运算符（+）相加在一起，创建一个新的字符串；你也可以通过加法赋值运算符（+=）将一个字符串添加到一个已经存在字符串变量上；你也可以用 append() 方法将一个字符附加到一个字符附加到一个字符串变量的尾部： 123var welcome = &quot;hello world&quot;let exclamationMark: Character = &quot;!&quot;wlecome.append(exclamationMark) 注意：你不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。 字符串插值字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。您插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中： 123let multiplier = 3let message = &quot;\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)&quot;//message 是 &quot;3 times 2.5 is 7.5&quot; 注意：插值字符串中写在括号中的表达式不能包含非转义反斜杠（\\），并且不能包含回车或者换行符。不过插值字符串可以包含其他字面量。 UnicodeUnicode是一个国际标准，用于文本的编码和表示。它使您可以用标准格式表示来自任意语言几乎所有的字 符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。 Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。 字符串字面量的特殊字符字符串字面量可以包含以下特殊字符:• 转义字符 \\0(空字符)、\\\\(反斜线)、\\t(水平制表符)、\\n(回车符)、\\&quot;（双引号）、\\&#39;(单引号)。• Unicode 标量，写成\\u{n}(u为小写)，其中 n为任意一到八位十六进制数且可用的 Unicode位码。 计算字符数量如果你想获得一个字符串中 Character值的数量，可以使用字符串的 characters 属性的 count 属性： 123let unusualMenagerie = &quot;Koala ?, Snail ?, Penguin ?, Dromedary ?&quot;print(&quot;unusualMenagerie has \\(unusualMenagerie.characters.count) characters&quot;) // 打印输出 &quot;unusualMenagerie has 40 characters&quot; 访问和修改字符串你可以通过字符串的属性和方法来访问和修改它，当然也可以用下标语法完成。 字符串索引每一个 String 值都有一个关联的索引（index）类型，String.Index，它对应着字符串中的每一个Character 的位置。前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道 Character 的确定位置，就必须从 String 开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数（integer）做索引。使用 startIndex 属性可以获取一个 String 的第一个Character 的索引。使用 endIndex 属性可以获取最后一个 Character的后一个位置的索引。因此，endIndex 属性不能作为一个字符串的有效下标。如果 String 是空串，startIndex 和 endIndex 是相等的。通过调用 String 的 index(before:) 或 index(after:) 方法，可以立即得到前面或后面的一个索引。您还 可以通过调用 index(_:offsetBy:) 方法来获取对应偏移量的索引，这种方式可以避免多次调用 index(befor e:) 或index(after:) 方法。 123456789101112let greeting = &quot;Guten Tag&quot;greeting[greeting.startIndex]// G greeting[greeting.index(before: greeting.endIndex)]// ggreeting[greeting.index(after: greeting.startIndex)]// ugreeting.index(before: greeting.endIndex)// 8let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// a 试图获取越界索引对应的 Character ，将引发一个运行时错误。 1greeting[greeting.endIndex] // error greeting.index(after: endIndex) // error 使用 characters 属性的 indices 属性会创建一个包含全部索引的范围(Range)，用来在一个字符串中访问单个字符。 12345for index in greeting.characters.indices &#123; print(&quot;\\(greeting[index]) &quot;,terminator: &quot;&quot;)&#125;// 由于Swift2 将print 和 println 合并了，并且默认的行为是 println，所以如果你不想自动在字符串末尾添加new line的话，就需要使用terminator参数来指定字符串的结尾。//打印输出 ：G u t e n T a g 插入和删除调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一段字符串。 12345var welcome = &quot;hello&quot;welcome.insert(&quot;!&quot;, at: welcome.endIndex)// welcome 变量现在等于 &quot;hello!&quot;welcome.insert(contentsOf: &quot; there&quot;.characters, at: welcome.index(before: welcome.endIndex))// welcome 变量现在等于 &quot;hello there!&quot; 调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。 123456welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome 现在等于 &quot;hello there&quot;let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome 现在等于 &quot;hello there&quot; 比较字符串Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。 字符串/字符相等字符串/字符可以用等于操作符（==）和不等于操作符（!=）。 1let quotation = &quot;We&apos;re a lot alike, you and I.&quot; let sameQuotation = &quot;We&apos;re a lot alike, you and I.&quot; if quotation == sameQuotation &#123; print(&quot;These two strings are considered equal&quot;) &#125; // 打印输出 &quot;These two strings are considered equal&quot; 前缀/后缀相等通过调用字符串的 hasPrefix(_:) / hasSuffix(_:) 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个 String 类型的参数，并返回一个布尔值。 下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置: 1let romeoAndJuliet = [ &quot;Act 1 Scene 1: Verona, A public place&quot;, &quot;Act 1 Scene 2: Capulet&apos;s mansion&quot;, &quot;Act 1 Scene 3: A room in Capulet&apos;s mansion&quot;, &quot;Act 1 Scene 4: A street outside Capulet&apos;s mansion&quot;, &quot;Act 1 Scene 5: The Great Hall in Capulet&apos;s mansion&quot;, &quot;Act 2 Scene 1: Outside Capulet&apos;s mansion&quot;, &quot;Act 2 Scene 2: Capulet&apos;s orchard&quot;, &quot;Act 2 Scene 3: Outside Friar Lawrence&apos;s cell&quot;, &quot;Act 2 Scene 4: A street in Verona&quot;, &quot;Act 2 Scene 5: Capulet&apos;s mansion&quot;, &quot;Act 2 Scene 6: Friar Lawrence&apos;s cell&quot; ] 您可以调用 hasPrefix(_:) 方法来计算话剧中第一幕的场景数: 1var act1SceneCount = 0 for scene in romeoAndJuliet &#123; if scene.hasPrefix(&quot;Act 1 &quot;) &#123; act1SceneCount += 1 &#125; &#125; print(&quot;There are \\(act1SceneCount) scenes in Act 1&quot;) // 打印输出 &quot;There are 5 scenes in Act 1&quot; 相似地，您可以用 hasSuffix(_:) 方法来计算发生在不同地方的场景数: 12345var mansionCount = 0 var cellCount = 0 for scene in romeoAndJuliet &#123; if scene.hasSuffix(&quot;Capulet&apos;s mansion&quot;) &#123; mansionCount += 1 &#125; else if scene.hasSuffix(&quot;Friar Lawrence&apos;s cell&quot;) &#123; cellCount += 1 &#125; &#125; print(&quot;\\(mansionCount) mansion scenes; \\(cellCount) cell scenes&quot;) // 打印输出 &quot;6 mansion scenes; 2 cell scenes&quot;","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(四)","date":"2017-07-21T02:59:58.000Z","path":"2017/07/21/SwiftIntroduceFourth/","text":"作者刘文涛转载请注明出处 基本运算符运算符是检查、改变、合并值的特殊符号或短语。例如，加号(+)将两个数相加（如 let i = 1 + 2）。更复杂的运算例子包括 逻辑与运算符 &amp;&amp; （如 if enteredDoorCode &amp;&amp; passedRetinaScan）。Swift支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如：赋值符 （=）不返回值，以防止把想要判断相等运算符（==）的地方写成赋值符导致的错误。算数运算符（+,-,*,/,%等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用Swift的溢出运算符来实现溢出。 Swift还提供了 C 语言没有的表达两数之间的值的区间运算符（a..&lt;b 和 a...b），这方便我们表达一个区间内的数值。 术语运算符分为一元、二元和三元运算符： • 一元运算符对单一操作对象操作(如 -a )。一元运算符分前置运算符和后置运算符,前置运算符需紧跟在 操作对象之前(如 !b ),后置运算符需紧跟在操作对象之后(如 c! )。• 二元运算符操作两个操作对象(如 2 + 3 ),是中置的,因为它们出现在两个操作对象之间。• 三元运算符操作三个操作对象,和 C 语言一样,Swift 只有一个三元运算符,就是三目运算符( a ? b : c)。 受运算符影响的值叫操作数，在表达式 1 + 2 中，加号 + 是二元运算符，他的两个操作数是值 1 和 2 。 溢出运算符Swfit为整型计算提供了5个&amp;符号开头的溢出运算符。 溢出加法 &amp;+溢出减法 &amp;-溢出乘法 &amp;*溢出除法 &amp;/溢出求余 &amp;% 比如溢出加法运算符（&amp;+）。所有的这些溢出运算符都是以 &amp; 开头的。 值的上溢出下面的例子使用了溢出加法 &amp;+来解剖的无符整数的上溢出 1234var willOverflow = UInt8.max//willOverflow 等于UInt8的最大整数 255willOverflow = willOverflow &amp;+ 1//这时候 willOverflow 等于 0 willOverflow 用 UInt8 所能承载的最大值 255（二进制 11111111），然后用 &amp;+ 加1.然后 UInt8 就无法表达这个新值的二进制了，也就导致了这个新值上溢出了。溢出后，新值在 UInt8 的承载范围内的那部分是 00000000，也就是 0。 赋值运算符赋值运算符 （a = b ），表示用 b 的值来初始化或者更新 a 的值。与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以下面的代码是错误的： 123456let (x, y) = (1, 2)// 现在 x 等于 1,y 等于 2if x == y &#123; //此句错误, 因为 x = y 并不返回任何值&#125; 这个特性使你无法把（==）错写成（=），由于 if x = y 是错误代码，Swift能帮你避免此类错误的发生。 算术运算符Swift 中所有的数值类型都支持了基本的四则算术运算符：• 加法(+)• 减法(-)• 乘法(*)• 除法(/) 加法运算符也可用于 String 的拼接： 1&quot;hello&quot; + &quot; world&quot; //等于&quot;hello world&quot; 求余运算符求余运算符 （a % b） 是计算 b 的多少倍刚刚好可以容入a,返回多出来的那部分 （余数）。在对负数求余时，负数的符号会被忽略。这意味着 a % b 和 a % -b 的结果是相同的。 空合运算符空合运算符 （a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认值 b。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。空合运算符是对以下代码的简短表达方法： 1a != nil ? a! : b 上述代码使用了三目运算符，当可选类型 a 的值不为空时，进行强制解封 (a!)，访问 a 中的值;反之返回默认值 b 。无疑空合运算符( ?? )提供了一种更为优 的方式去封装条件判断和解封两种行为,显得简洁以及更具可读性。 注意：如果 a 为非空值（non-nil），那么值 b 将不会被计算。这也就是所谓的短路求值。 下文例子采用空合运算符,实现了在默认颜色名和可选自定义颜色名之间抉择: 1234let defaultColorName = &quot;red&quot;var userDefinedColorName: String? //默认值为 nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 “red” 区间运算符Swift 提供了两个方便表达一个区间的值的区间运算符。 闭区间运算符闭区间运算符（a…b）定义一个包含从 a 到 b （包含 a 和 b）的所有值的区间。 a 的值不能超过 b。 半开区间运算符半开区间运算符( a..&lt;b )定义一个从 a 到 b 但不包括 b 的区间。之所以称为半开区间，是因为该区间包含第一个值而不包含最后的值。半开区间的实用性在于当你使用一个从 0 开始的列表(如数组)时,非常方便地从0数到列表的长度。 1234567891011let names = [&quot;Mike&quot;,&quot;Jack&quot;,&quot;Alex&quot;,&quot;Brian&quot;]let count = names.countfor i in 0..&lt;count &#123; print(&quot;第 \\(i + 1) 个人叫 \\(names[i])&quot;)&#125;/** 第 1 个人叫 Mike 第 2 个人叫 Jack 第 3 个人叫 Alex 第 4 个人叫 Brian */ 逻辑运算符逻辑运算符的操作对象是逻辑布尔值。Swift 支持 C 语言的三个标准逻辑运算。• 逻辑非( )• 逻辑与( )• 逻辑或( ) 逻辑非运算符逻辑非运算符（!a）对一个布尔值取反，使得 true 变 false，false 变 true。它是一个前置运算符,需紧跟在操作数之前,且不加空格。读作 非 a 。 逻辑与运算符逻辑与运算符( a &amp;&amp; b )表达了只有 a 和 b 的值都为 true 时,整个表达式的值才会是 true 。 逻辑或运算符逻辑或运算符( a || b )是一个由两个连续的 | 组成的中置运算符。它表示了两个逻辑表达式的其中一个为 true ,整个表达式就为 true 。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(三)","date":"2017-07-18T02:59:58.000Z","path":"2017/07/18/SwiftIntroduceThird/","text":"作者刘文涛转载请注明出处 前言由于最近工作比较忙，一直没时间跟新博客。最近项目告一段落了，继续开始我的Swift学习之路。 数值型字面量 整数字面量可以被写作：一个十进制数，没有前缀一个二进制数，前缀 0b一个八进制数，前缀 0o一个十六进制数，前缀 0x下面的所有整数字面量的十进制都是 17： 1234let decimalInteger = 17 let binaryInteger = 0b10001 //二进制的17let octalInteger = 0o21 //八进制的17let hexadecimalInteger = 0x11 //十六进制的17 数值型类型转换通常来讲，即使代码中的整数常量和变量已知非负，也请使用 Int 类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。只有在必要的时候才使用其他整数类型，比如要处理外部额长度明确的数据或者为了优化性能、内存占用等等。使用显示指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。 整数转换不同整数类型的变量和常量可以存储不同范围的数字。Int8 类型的常量或者变量可以存储的数字范围是 -128~127，而 UInt8 类型能存储的数字范围是 0~255 。如果数字超出了常量或者变量可存储的范围，编译的时候会报错： 12let cannotBeNegative: UInt = -1 //UInt8 类型不能存储负数，所以会报错let tooBig: Int8 = Int8.max + 1 //Int8 类型不能存储超过最大值的数，所以会报错 由于每种整数类型都可以存储不同范围的值,所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式,可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。 123let twoThousand: UInt16 = 2000let one: Uint8 = 1let TwoThousandAndOne = twoThouand + UInt16(one) 因为两个常量的类型不一样 不能直接相加，所以要调用 UInt16(one) 来创建一个新的 UInt16 数字并用 one 的值来初始化，然后使用这个新数字来计算。SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部, UInt16 有一个 构造器,可以接受一个 UInt8 类型的值,所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16 。注 意,你并不能传入任意类型的值,只能传入 UInt16 内部有对应构造器的值。不过你可以扩展现有的类型来让它 可以接收其他类型的值(包括自定义类型)。 整数和浮点数转换整数和浮点数的转换必须显式指定类型： 1234let three = 3let point = 0.14159let pi = Double(three) + point// pi等于 3.14159，所以被推测为Double类型 这个例子中，常量 three 的值被用来创建一个 Double 类型的值，所以加号两边的数类型需相同。如果不进行转换，两者无法相加。浮点数到整数的反向转换同样行，整数类型可以用 Double 或者 Float 类型来初始化。 类型别名类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 typealias关键字来定义类型别名。当你想给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源数据： 1typealias AudioSample = UInt16 定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名： 12var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在是0 本例中，AudioSample 被定义为 UInt16 的一个别名。因为他是别名。AudioSample.min实际上是 UInt16.min ，所以会给 maxAmplitudeFound 赋一个初值 0。 布尔值Swift有一个基本的布尔（Boolean）类型，叫做 Bool 。布尔值指逻辑上的值，因为它们只能是真或者假。Swift有两个布尔常量， true 和 false 。 12let t = truelet f = false t 和 f 的类型会被推断为 Bool，因为它们的初值是布尔字面量。就像之前提到的 Int 和 Double 一样，如果你创建变量的时候给他们赋值 true 或者 false ，那你不需要将常量或者变量声明为 Bool 类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，折让Swift的代码更简洁并且可读性更高。 元组元组（tuples）可以把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。下面这个例子中, (404, &quot;Not Found&quot;) 是一个描述 HTTP 状态码(HTTP status code)的元组。HTTP 状态码是 当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个 404 Not Found 状态码。 12let http404Error = (404 \"Not Found\")// http404Error 的类型是（Int， String），值是(404, \"Not Found\") (404, &quot;Not Found&quot;)元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分，这个元组可以被描述为 “一个类型为（Int， String）的元组”。 你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为（Int, Int, Int）或者（String, Bool）或者其他任何你想要的组合的元组。你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了： 12345let (statusCode, statusMessage) = http404Errorprint(\"The status code is \\(statusCode)\")//输出 \"The status code is 404\"print(\"The status message is \\(statusMessage)\") // 输出 \"The status message is Not Found\" 如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线(_)标记： 1let (justTheStatusCode, _) = http404Error print(&quot;The status code is \\(justTheStatusCode)&quot;) // 输出 &quot;The status code is 404&quot; 此外，你还可以通过下标来访问元组中的单个元素，下标从 0 开始： 1print(&quot;The status code is \\(http404Error.0)&quot;) // 输出 &quot;The status code is 404&quot; print(&quot;The status message is \\(http404Error.1)&quot;) // 输出 &quot;The status message is Not Found&quot; 你可以在定义元组的时候给单个元素命名： 1let http200Status = (statusCode:200, description: &quot;OK&quot;) 给元组中的元素命名后，你可以通过名字来获取这些元素的值： 12print(&quot;The status code is \\(http200Status.statusCode)&quot;) // 输出 &quot;The status code is 200&quot; print(&quot;The status message is \\(http200Status.description)&quot;) // 输出 &quot;The status message is OK&quot; 作为函数返回值时,元组非常有用。一个用来获取网页的函数可能会返回一个 (Int, String) 元组来描述是否 获取成功。和只能返回一个类型的值比较起来,一个包含两个不同类型值的元组可以让函数的返回信息更有用。 注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。 可选类型使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示：有值， 等于 x或者没有值 注意：C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性,一个方法要不返回一 个对象要不返回 nil , nil 表示“缺少一个合法的对象”。然而,这只对对象起作用——对于结构体,基本的 C 类型或者枚举类型不起作用。对于这些类型,Objective-C 方法一般会返回一个特殊值(比如 NSNotFound )来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而,Swift 的可选类型可以让 你暗示任意类型的值缺失,并不需要一个特殊值。 来看一个例子。Swift的 Int 类型有一种构造器，作用是将一个 String 值转换成一个 Int 值。然而，并不是所有的字符串都可以抓换成一个整数。字符串 “123” 可以被转换成数字 123 ，但是字符串 “hello， world” 不行。下面的例子使用这种构造器来尝试将一个 String 转换成 Int： 123let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber)// convertedNumber 被推测为类型 &quot;Int?&quot;,或者类型 &quot;optional Int&quot; 因为该构造器可能会失败，所以它返回一个可选类型（optional） Int，而不是一个 Int。一个可选的 Int 被写作 Int? 而不是 Int 。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。（不能包含其他任何值，比如 Bool值或者 String值。只能是 Int 或者什么也没有。） nil你可以给可选变量赋值为 nil 来表示它没有值: 1234var serverResponseCode: Int? = 404// serverResponseCode 包含一个可选的 Int 值 404serverResponseCode = nil// serverResponseCode 现在不包含值 注意： nil 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。 如果你声明了一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil。 注意： Swift 的 nil 和 OC 中的 nil 并不一样。在 OC 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针–它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。 if语句以及强制解析你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。如果可选类型有值，它将不等于 nil： 1if convertedNumber != nil &#123; print(&quot;convertedNumber contains some integer value.&quot;) &#125; // 输出 &quot;convertedNumber contains some integer value.&quot; 当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值,请使用它。”这被称为可选值的强制解析(forced unwrapping): 1234if convertedNumber != nil &#123; print(&quot;convertedNumber has an integer value of \\(convertedNumber!).&quot;)&#125;// 输出 &quot;convertedNumber has an integer value of 123.&quot; 可选绑定使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。你可以像下面那样在 if 语句中写一个可选绑定： 123456if let actualNumber = Int(possibleNumber)&#123; print(&quot;\\&apos;\\(possibleNumber)\\&apos; has an integer value of \\(actualNumber)&quot;)&#125; else &#123; print(&quot;\\&apos;\\(possibleNumber)\\&apos; could not be converted to an integer&quot;)&#125;// 输出 &quot;&apos;123&apos; has an integer value of 123&quot; 这段代码可以被理解为：“如果 Int(possibleNumber) 返回的可选 Int 包含一个值,创建一个叫做 actualNumber 的新常量并将可选 包含的值赋给它。”如果转换成功, actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化 过,所以不需要再使用 ! 后缀来获取它的值。在这个例子中,actualNumber 只被用来输出转换结果。你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作 actualNumber 的值,你可以改 成 if var actualNumber ,这样可选类型包含的值就会被赋给一个变量而非常量。 隐式解析可选类型如上所述，可选类型暗示了常量或者变量可以”没有值“。可选可以通过 if 语句来判断是否有值，如果有值的话就可以通过可选绑定来解析值。有的时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总是会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改为感叹号（String!）来声明一个隐式解析可选类型。当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中。一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都是用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别： 12345let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! //需要感叹号来获取值let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString //不需要感叹号 你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾,而不是每次取值的可选名字的结尾。 注意:如果一个变量之后可能变成 nil 的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否 是 nil 的话,请使用普通可选类型。 错误处理你可以使用错误处理（error handling）来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。 123func canThrowAnError() throws&#123; // 这个函数有可能抛出错误&#125; 一个函数可以通过在声明中添加 throws 关键字来抛出错误消息。当你的函数能抛出错误消息时，你应该在表达式中前置 try关键字。 123456do &#123; try canThrowAnError() // 没有错误消息抛出&#125; catch &#123; // 有一个错误消息抛出&#125; 一个 do 语句创建了一个新的包含作用域，使得错误能被传播到一个或多个 catch 从句。 断言可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个 断言(asse rtion) 来结束代码运行并通过调试来找到值缺失的原因。如果你的代码在调试环境下触发了一个断言,比如你在 Xcode 中构建并运行一个应用,你可以清楚地看到不合法 的状态发生在哪里并检查断言被触发时你的应用的状态。此外,断言允许你附加一条调试信息。你可以使用全局 assert(_:_:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息,当表达式的结果为 false 的时候这条信息会被显示: 123let age = -3assert(age &gt;= 0, &quot;A person&apos;s age cannot be less than zero&quot;)// 因为 age &lt; 0,所以断言会触发 在这个例子中,只有 age &gt;= 0 为 true 的时候,即 age 的值非负的时候,代码才会继续执行。如果 age 的值是负数,就像代码中那样, age &gt;= 0 为 false ,断言被触发,终止应用。 注意:当代码使用优化编译的时候,断言将会被禁用,例如在 Xcode 中,使用默认的 target Release 配置选项来 build 时,断言会被禁用。 何时使用断言当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景： 整数类型的下标索引被传入一个自定义下标实现,但是下标索引值可能太小或者太大。 需要给函数传入一个值,但是非法的值可能导致函数不能正常执行。 一个可选值现在是 nil ,但是后面的代码运行需要一个非 nil 值。 注意: 断言可能导致你的应用终止运行,所以你应当仔细设计你的代码来让非法条件不会出现。然而,在你的应用发布之前,有时候非法条件可能出现,这时使用断言可以快速发现问题。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(二)","date":"2017-06-22T05:37:47.000Z","path":"2017/06/22/SwiftIntroduceSecond/","text":"作者刘文涛转载请注明出处 前言Swift 包含了 C 和 Objective-C 上所有基础数据类型，int表示整型值；Double 和 Float表示浮点型的值。Bool是布尔型值； String是文本型数据。Swift还提供了三个基本的集合类型，Array， Set 和 Dictionary，详见集合类型。 就像 C 语言一样，Swift使用变量来进行存储并通过变量名来关联值。在Swift中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 的语言常量更强大。在Swift中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰的表达你的意图。除了我们熟悉的类型，Swift还增加了 OC 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。 Swift还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那有一个值，并且它等于 x”或者“那没有值”。可选有点像在 OC 中使用 nil，但是它可以用在任何类型上，不仅仅是类。可选类型对比 OC 中的 nil 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。 Swift 是一门类型安全的语言，这意味着 Swift 可以让你清除的知道值的类型。如果你的代码期望得到一个 String ，类型安全会阻止你不小心传入一个 Int。同样的，如果你的代码期望得到一个 String，类型安全会阻止你意外传入一个可选的String。类型安全可以帮助你在开发阶段尽早发现并修正错误。 常量和变量常量和变量把一个名字和一个指定类型的值关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。 声明常量和变量常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登陆的次数： 12let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0 这两行代码可以被理解为：“声明一个名字是 maximumNumberOfLoginAttempts 的新常量,并给它一个值 10 。然后,声明一个名字是 rrentLoginAttempt 的变量并将它的值初始化为 0 。” 在这个例子中，允许最大尝试登陆次数被声明为一个常量，因为这个值不会改变。当前尝试登陆次数被声明为一个变量，因为每次尝试登陆失败的时候都需要增加这个值。 你可以在一行中声明多个常量或者多个变量，使用逗号隔开： 1var x = 0.0, y = 0.0, z = 0.0 注意：如果你的代码中有不需要改变的值，请使用let关键字将它声明为常量。只将需要改变的值声明为变量。 类型标注当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。这个例子给welcomeMessage变量添加了类型标注，表示这个变量可以存储String类型的值： 1var welcomeMessage: String 声明中的冒号代表着”是…类型“，所以这行代码可以被理解为：”声明一个类型为String，名字为welcomeMessage的变量。“类型为String的意思是”可以存储任意String类型的值。“welcomeMessage 变量现在可以被设置成任意字符串： 1welcomeMessage = \"Hello\" 你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注： 1var red, green, blue: Double 注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型。在上面的例子中,没有给 welcomeMessage 赋初始 值,所以变量 welcomeMessage 的类型是通过一个类型标注指定的,而不是通过初始值推断的。 常量和变量的命名你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符： 12let π = 3.14let 你好 = \"你好\" 常量和变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。 一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何,你应当避免使用关键字作为常量或变量名,除非你别无选择。 你可以更改现有的变量值为其他同类型的值，在下面的例子中，friendlyWelcome的值从 &quot;Hello!&quot;改为了 &quot;Bonjour!&quot; 123var friendlyWelcome = \"Hello!\"friendlyWelcome = \"Bonjour!\"// friendlyWelcome 现在是 \"Bonjour!\" 与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译器报错： 1let languageName = \"Swift\" languageName = \"Swift++\" // 这会报编译时错误 - languageName 不可改变 输出常量和变量你可以用print()函数来输出当前常量或变量的值： 1print(friendlyWelcome) Swift 用字符串插值(string interpolation)的方式把常量名或者变量名当做占位符加入到长字符串中，Swift会用当前常量或者变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义： 12print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\") // 输出 \"The current value of friendlyWelcome is Bonjour! 注释请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift的注释与 C 语言的注释非常相似。单行注释以双正斜杠（//）作为起始标记： 1// 这是一个注释 你也可以进行多行注释,其起始标记为单个正斜杠后跟随一个星号( /*),终止标记为一个星号后跟随单个正斜 杠(*/): 12/* 这是一个, 多行注释 */ 与C语言多行注释不同，Swift的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中在嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记： 12345/* 这是第一个多行注释的开头 /* 这是第二个被嵌套的多行注释 */ 这是第一个多行注释的结尾*/ 通过运用嵌套多行注释，你可以快捷方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。 分号与其他大部分编程语言不同，Swift并不强制要求你在每条语句的结尾处使用分号（;），当然你也可以按照你自己的习惯添加分号。有一种情况下必须要使用分号，即你打算在同一行内写多条独立的语句： 12let cat = \"?\"; print(cat)输出 ? 整数整数就是没有小数部分的数字，比如 42,-23。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是 UInt8，32位有符号整数类型是 Int32。就像Swift的其他类型一样，整数类型采用大写命名法。 整数范围你可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值： 12let minValue = UInt8.min // minValue 为 0,是 UInt8 类型let maxValue = UInt8.max // maxValue 为 255,是 UInt8 类型 min 和 max所传回值的类型，正是其所对的整数类型（如上例UInt8, 所传回的类型是UInt8），可用在表达式中相同类型值旁。 Int一般来说，你不需要专门指定整数的长度。Swift提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：• 在32位平台上, Int 和 Int32 长度相同。• 在64位平台上, Int 和 Int64 长度相同。除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是32位平台上，Int可以存储的整数范围也可以达到 -2,147,483,648 ~ 2,147,483,647,大多数时候这已经足够大了。 UIntSwift 也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同：• 在32位平台上, UInt 和 UInt32 长度相同。• 在64位平台上, UInt 和 UInt64 长度相同。 注意：尽量不要使用UInt,除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用 Int ，即使你要存储的值已知是非负的。同意使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断。 浮点数浮点数是有小数部分的数字，比如：3.1415，0.1 和 -273.15。浮点类型比整数类型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift提供了两种有符号浮点数类型：Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。Float 表示32位浮点数。精度要求不高的话可以使用此类型。注意：Double 精确度很高，至少有15位数字，而Float只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 Double。 类型安全和类型推断Swift是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。由于Swift是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误，这可以让你在开发的时候尽早发现并修复错误。当你要处理不同的类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。因为有类型的推断，和C或者OC比起来Swift很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。当你声明常量或者变量并赋初值的时候类型推断非常有用。例如，如果你给一个新常量赋值 42 并且没有标明类型，Swift可以推断出常量类型是Int，因为你给它赋的初始值看起来像一个整数。同理，如果你没有给浮点字面量标明类型，Swift会推断你想要的是Double。如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型。 1let pi = 3 + 0.14159 // pi 会被推测为 Double 类型","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Swift学习之路--Swift基础(一)","date":"2017-06-15T02:42:16.000Z","path":"2017/06/15/SwiftIntroduceFirst/","text":"作者刘文涛转载请注明出处 前言刚接触Swift的时候是2.2版本，当时只是大概了解学习了一下一些Swift基础。现在由于项目不忙，决定在从基础重新学习一下Swift这门语言。这次学习的是Swift3.0版本，Swift3.0是自Swift开源以来第一个大的版本更新。从语言角度不兼容之前的Swift2.2和Swift2.3版本。Swift3.0版本的更新说明大家可以查看官方的blog说明，也可以关注SwiftGG的最新文章。 关于SwiftSwift是一种新的编程语言，用于编写iOS，macOS，watchOS和tvOS的应用程序。Swift结合了C和OC的优点并且不受C兼容性的限制。Swift采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift是基于成熟而且备受喜爱的Cocoa和Cocoa Touch框架，它的降临将重新定义软件开发。Objective-C开发者对Swift并不会感到陌生。它采用了Objective-C的命名参数以及动态对象模型，可以无缝对接到现有的Cocoa框架，并且可以兼容Objective-C代码。在此基础之上，Swift还有许多新特性并且支持过程式编程和面向对象编程。Swift对初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满变现力和趣味的系统编程语言。它支持代码预览(playgrounds)，这个革命性的特性可以使程序员在不编译运行应用的前提下运行Swift代码并实时查看结果。 Swift初见打印“hello world” 1print(&quot;hello world!&quot;) 如果你写过C或者Objective-C代码，那么你应该很熟悉这种形式——在Swift中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口点，所以你也不需要main()函数。你同样不需要在每个语句结尾写上分号。 简单值使用 let 来声明常量，使用 var 来声明变量。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能为它赋值一次。也就是说你可以用常量来表示这样的一个值：你只需要决定一次，但是需要使用很多次。 123var myVariable = 42myVariable = 50let myConstant = 42 常量或者变量的类型必须和你赋给他们的值一样。然而，你不用明确的声明类型，声明的同时赋值的话，编译器会自动推断类型。在上面的例子中，编译器推断出 myVariable 是一个整数（integer）因为它的初始值是整数。如果初始值没有提供足够的信息（或者没有初始值），那么需要你在变量后面声明类型，用冒号分割。 1let explicitDouble: Double = 70 值永远不会被隐式转换为其他类型。如果你需要把一个值转换成其他类型，请显式转换。 123let label = \"The width is\"let width = 100let widthLabel = label + String(width) 有一种更简单的把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠。例如： 1234let apples = 3let oranges = 5let appleSummary = \"I have \\(apples) apples.\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 使用方括号[]来创建数组和字典，并使用下标或者键（key）来访问元素。最后一个元素后面允许有个逗号。 12345678var shoppingList = [\"catfish\",\"water\",\"tulips\",\"blue paint\"]shoppingList[1] = \"bottle of water\" //将数组下标为1的元素替换了var occupations = [ \"Malcolm\": \"Captain\", \"Keylee\": \"Mechanic\",]occupations[\"Jayne\"] = \"Public Relations\" //添加一个字典occupations 要创建一个空数组或者字典，使用初始化语法。 12let emptyArray = [String]()let emptyDictionary = [String: Float]() 如果类型信息可以被推断出来,你可以用 [] 和 [:] 来创建空数组和空字典——就像你声明变量或者给函数传参 数的时候一样。 12shoppingList = []occupations = [:] 控制流使用 if 和 switch 来进行条件操作，使用 for-in 、for 、while 和 repeat-while 来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。 12345678910let individualScores = [75,43,122,109,12]var teamScore = 0for score in individualScores &#123; if score &gt; 50 &#123; teamScore += 3 &#125;else&#123; teamScore += 1 &#125;&#125;print(teamScore) 在 if 语句中，条件必须是一个布尔表达式—这意味着像 if score {...} 这样的代码将报错，而不会隐式地与0做对比。你可以一起使用 if 和 let 来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者是 nil 以表示值缺失。在类型后面加一个问号来标记这个变量的值是可选的。 123456789var optionalString: String? = \"Hello\"print(optionalString == nil)var optionalName: String? = \"liuwentao\"var greeting = \"Hello!\"if let name = optionalName &#123; greeting = \"Hello, \\(name)\"&#125; 如果变量的可选值是nil，条件会判断为 false，大括号中的代码会被跳过。如果不是 nil，会将值解包并赋给 let 后面的常量，这样代码块中就可以使用这个值了。另一种处理方法是通过使用 ?? 操作符来提供一个默认值。如果可选值缺失的话可以使用默认值来代替。 123let nickName: String? = nillet fullName: String = \"liuwentao\"let informalGreeting = \"Hi \\(nickName ?? fullName)\" switch 支持任意类型的数据以及各种比较操作————不仅仅是整数以及测试相等。 1234567891011let vegetable = \"red pepper\"switch vegetable &#123;case \"celery\": print(\"Add some raisins and make ants on a log.\")case \"cucumber\", \"watercress\": print(\"That would make a good tea sandwich.\")case let x where x.hasSuffix(\"pepper\"): print(\"Is it a spicy \\(x)?\")default: print(\"Everything tastes good in soup.\")&#125; 注意 let 在上述例子的等式中是如何使用的，它将匹配等式的值赋给常量 x。运行 switch 中匹配到的句子之后，程序会退出 switch 语句，并不会继续向下运行，所以不需要在每个句子结尾写 break。你可以使用 for-in 来遍历字典，需要两个变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。 1234567891011121314let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25],]var largest = 0for (kid, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) 使用 while 来重复运行一段代码知道不满足条件。循环条件也可以在结尾，保证能至少循环一次。 1234567891011var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n)var m = 2repeat &#123; m = m * 2&#125; while m &lt; 100print(m) 你可以在循环中使用..&lt;来表示范围。 123456//你可以在循环中使用 ..&lt; 来表示范围。var total = 0for i in 0..&lt;4 &#123; total += i&#125;print(total) 使用 ..&lt; 创建的范围不包含上界,如果想包含的话需要使用 ... 。 函数和闭包使用 func 来声明一个函数，使用名字和参数来调用函数。使用 -&gt;来指定函数的返回值类型。 1234func greet(person: String, day: String) -&gt; String &#123; return \"Hello \\(person), today is \\(day)\"&#125;greet(person: \"liuwentao\", day: \"2017-6-15\") 默认情况下,函数使用它们的参数名称作为它们参数的标签,在参数名称前可以自定义参数标签,或者使用_ 表示不使用参数标签 12345func greet(_ person: String, on day: String) -&gt; String &#123; return \"Hello \\(person), today is \\(day)\"&#125;greet(\"liuwentao\", on:\"wednesday\") 使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。 12345678910111213141516171819202122func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int)&#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125;else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;let statistics = calculateStatistics(scores: [2,9,5,100,3,9])print(statistics.max)print(statistics.min)print(statistics.2)print(statistics.1) 函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式： 123456789func sumOf(numbers:Int...) -&gt; Int&#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf()sumOf(numbers: 42,100,78) 函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。 123456789func returnFifteen() -&gt; Int&#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125;returnFifteen() 函数是第一等类型，这意味着函数可以作为另一个函数的返回值。 12345678func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment = makeIncrementer()increment(9) 函数也可以当成参数传入另一函数。 1234567891011121314func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item)&#123; return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool&#123; return number &lt; 10&#125;var numbers = [10,29,13,9]hasAnyMatches(list: numbers, condition: lessThanTen) 函数实际上是一种特殊的闭包：它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{}来创建一个匿名的闭包。使用 in 将参数和返回值类型声明与闭包函数体进行分离。 12345numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number return result&#125;) 有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。 12let mappedNumbers = numbers.map(&#123; number in 3 * number&#125;)print(mappedNumbers) 你可以通过参数位置而不是参数名字来引用参数————这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。 12let sortedNumbers = numbers.sorted&#123; $0 &gt; $1 &#125;print(sortedNumbers) 对象和类使用 class和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。 123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides\" &#125;&#125; 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。 123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription() 这个版本的 Shape 类缺少了一些重要的东西：一个构造函数来初始化类实例。使用 init 来创建一个构造器。 123456789101112131415class NameShape &#123; var numberOfSides: Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125; &#125;let testNameShape = NameShape( name: \"qq\")testNameShape.numberOfSides = 10testNameShape.simpleDescription() 注意 self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值————无论是通过声明（就像 numberOfSides）还是通过构造器（就像name）。如果你需要在删除对象之前进行一些清理工作，使用 deinit 创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。子类如果要重写父类方法的话，需要用 override 标记 ———— 如果没有添加 override 就重写父类方法的话编译器会报错。编译器同样会检测 override 标记的方法是否确实在父类中。 1234567891011121314151617181920class Square: NameShape &#123; var sideLength: Double init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func simpleDescription() -&gt; String &#123; return \"A square with sides of length \\(sideLength).\" &#125;&#125;let test = Square(sideLength:5.2, name: \"my test square\")test.area()test.simpleDescription() 除了储存简单的属性之外，属性可以有 getter 和 setter。 123456789101112131415161718192021222324252627class EquilateralTriangle:NameShape &#123; var sideLength: Double = 0.0 init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double &#123; get&#123; return 3.0 * sideLength &#125; set &#123; sideLength = newValue / 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"An equilateral triagle with sides of length \\(sideLength).\" &#125; &#125;var triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")print(triangle.perimeter)triangle.perimeter = 9.9print(triangle.sideLength) 在 perimeter的setter中，新值的名字是 newValue 。你可以在 set 之后显示的设置一个名字。注意 EquilateralTriangle 类的构造器执行了三步：1.设置子类声明的属性值2.调用父类的构造器3.改变父类定义的属性值。其他的工作比如调用方法、getters和setters也可以在这个阶段完成。如果你不需要计算属性，但是仍需要在设置一个新值之前或者之后运行代码，使用willSet和didSet。比如，下面的类确保三角形的边长总是和正方形的边长相同。 1234567891011121314151617181920212223class TriangleAndSquare &#123; var triangle : EquilateralTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square : Square &#123; willSet&#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size: Double, name: String) &#123; square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10,name: \"another test shape\")print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")print(triangleAndSquare.triangle.sideLength) 处理变量的可选值时，你可以再操作（比如方法、属性和子脚本）之前加 ?。如果?之前的值是nil,?后面的东西都会被忽略，并且整个表达式返回nil。否则，?之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。 12let optionalSquare: Square? = Square(sideLength: 2.5, name: \"optional square\")let sideLength = optionalSquare?.sideLength 枚举和结构体使用 enum来创建一个枚举。就想类和其他所有命名类型一样，枚举可以包含方法。 123456789101112131415161718enum Rank: Int &#123; case Ace = 1 case Two,Three,Fore,Five, Six, Seven func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return \"ace\" case .Two: return \"two\" case .Three: return \"three\" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.Acelet aceRawValue = ace.rawValue 默认情况下，Swift按照从0开始每次加1的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中，Ace被显式赋值为1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。使用init?(rawValue:)初始化构造器在原始值和枚举值之间进行转换。 123if let convertedRank = Rank(rawValue: 3)&#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。 12345678910111213141516enum Suit &#123; case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return \"spades\" case .Hearts: return \"hearts\" case .Diamonds: return \"diamonds\" case .Clubs: return \"clubs\" &#125; &#125; &#125;let hearts = Suit.Heartslet heartsDescription = hearts.simpleDescription() 注意，有两种方式可以引用Hearts成员：给hearts常量赋值时，枚举成员Suit.Hearts 需要用全名来引用，因为常量没有显示指定类型。在switch里，枚举成员使用缩写.Hearts来引用，因为self的值已经知道是一个Suit。已知变量类型的情况下你可以使用缩写。一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。例如，考虑从服务器获取日出日落的时间。服务器会返回正常结果或者错误信息。 123456789101112enum ServerResponse &#123; case Result(String, String) case Failure(String)&#125;let success = ServerResponse.Result(\"6:00 am\", \"8:09 pm\")let failure = ServerResponse.Failure(\"Out of cheese.\")switch success &#123;case let .Result(sunrise, sunset): let serverResponse = \"Sunrise is at \\(sunrise) and sunset is at \\(sunset).\"case let .Failure(message): print(\"Failure... \\(message)\")&#125; 注意日升和日落时间是如何从 ServerResponse 中提取到并与 switch的 case 相匹配的。 使用struct来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的区别就是结构体是传值，类是传引用。 12345678910struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return \"the \\(rank.simpleDescription()) of \\(suit.simpleDescription())\" &#125;&#125;let threeOfSpades = Card(rank: .Three,suit: .Spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 协议和扩展使用 protocol来声明一个协议。 1234protocol ExampleProtocol &#123; var simpleDescription:String &#123; get &#125; mutating func adjust()&#125; 类、枚举和结构体都可以实现协议。 12345678910111213141516171819202122class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = \"a very simple class\" var anotherProperty: Int = 69105 func adjust() &#123; simpleDescription += \" now 100% adjusted\" &#125; &#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct SimpleStructure:ExampleProtocol &#123; var simpleDescription: String = \"a very simple structure\" mutating func adjust() &#123; simpleDescription += \" (adjusted)\" &#125; &#125;var b = SimpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明 SimpleStructure 时候 ``mutating1234567891011121314使用 ``extension``来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。````objcextension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return &quot;The number \\(self)&quot; &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription)` 你可以像使用其他命名类型一样使用协议名–例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用。 123let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)// print(protocolValue.anotherProperty) // 去掉注释可以看到错误 即使protocolValue变量运行时的类型是simpleClass，编译器会把它的类型当做ExampleProtocol。这表示你不能调用类在它实现的协议之外实现的方法或者属性。 错误处理使用采用Error协议的类型来表示错误。 12345enum PrinterError:Error &#123; case OutOfPaper case NoToner case OnFire&#125; 使用throw来抛出一个错误并使用throws来表示一个可以抛出错误的函数。如果在函数中抛出一个错误，这个函数会立刻返回并且调用该函数的代码会进行错误处理。 123456func send(job: Int, toPrinter printerName: String) throws -&gt; String&#123; if printerName == \"Never Has Toner\" &#123; throw PrinterError.NoToner &#125; return \"job sent\"&#125; 有多种方式可以用来进行错误处理。一种方式是使用do-cash。在do代码块中，使用try来标记可以抛出错误的代码。在case代码块中，除非你另外命名，否则错误会自动命名为error。 123456do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Never Has Toner\") print(printerResponse)&#125; catch &#123;print(error)&#125; 可以使用多个catch块来处理特定的错误。参照switch中的case风格来写catch。 12345678910do &#123; let printerResponse = try send(job: 1440, toPrinter: \"Gutenberg\") print(printerResponse)&#125; catch PrinterError.OnFire &#123; print(\"I'll just put this over here, with the rest of the fire.\")&#125; catch let printerError as PrinterError &#123; print(\"Printer error: \\(printerError).\")&#125; catch &#123; print(error)&#125; 另一种处理错误的方式使用try?将结果转换为可选的。如果函数抛出错误，该错误会被抛弃并且结果为nil。否则的话，结果会是一个包含函数返回值的可选值。 12let printerSuccess = try? send(job: 1884, toPrinter: \"Mergenthaler\")let printerFailure = try? send(job: 1885, toPrinter: \"Never Has Toner\") 使用defer代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。使用defer，可以把函数调用之初就要执行的代码和函数调用结束时的扫尾代码写在一起，索然这两者的执行时机截然不同。 12345678910111213var fridgeIsOpen = falselet fridgeContent = [\"milk\", \"eggs\", \"leftovers\"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result &#125;fridgeContains(\"banana\")print(fridgeIsOpen) 泛型在尖括号里写一个名字来创建一个泛型函数或者类型。 12345678910func repeatItem&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result .append(item) &#125; return result&#125;print(repeatItem(repeating: \"knock\", numberOfTimes: 4)) 你也可以创建泛型函数、方法、类、枚举和结构体 123456enum OptionalValue&lt;Wrapped&gt; &#123; case None case Some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .NonepossibleInteger = .Some(100) 在类型名后面使用where来指定对类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。 1234567891011121314func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1, 2, 3], [3]) &lt;T: Equatable&gt; 和 &lt;T&gt; ... where T: Equatable&gt; 是等价的。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"iOS 动态下载系统提供的多种中文字体","date":"2017-06-07T05:53:08.000Z","path":"2017/06/07/DownloadFont/","text":"作者刘文涛转载请注明出处 一、功能简介1.前言为了实现更好的字体效果，有些应用在自己的应用资源包中加入了字体文件。但自己打包字体文件比较麻烦，原因在于：1.字体文件通常比较大，10~20M是常见的字体库大小。如果只是很少量的按钮字体需要设置，可以用一些工具把使用的汉字字体编码从字体库中抽取出来，以节省体积。但是如果是一些变化的内容需要自定义的字体，那么就只能打包整个字体库了。2.中文字体都是有版权的，在应用中加入特殊中文字体还需要处理相应的版权问题。从iOS6开始，苹果开始支持动态下载官方提供的中文字体到系统中。使用苹果官方的中文字体，即可以避免版权问题，又可以节省应用体积。 2.功能介绍使用动态下载中文字体的API可以动态的向iOS系统中添加字体文件，这些字体文件都是下载带到系统的目录中（模拟器中运行的目录是/Users/iosdev/Library/Developer/CoreSimulator/Devices/46DE5A8B-1C81-41F0-994D-BD6502EDEB58/data/Library/Assets/com_apple_MobileAsset_Font3/6da938c9f7fa36cae9ee066f7d75195c222fec07.asset/AssetData/WawaSC-Regular.otf）,所以并不会造成应用体积的增加。虽然第一次下载相关的中文字体需要一些网络开销和下载时间，但是这些字体文件下载完后可以在所有应用间共享，所以大部分应用都不需提示用户下载字体，因为很可能这些字体在之前被其他应用下载过了。 3.字体列表在官方文档中，苹果列出了提供动态下载和使用的中文字体文件列表。不过，由于下载的时候需要使用的名字是PostScript名称，所以如果你真正要动态下载相应的字体的话，还需要使用Mac内自带的应用字体册(Font Book)来获得相应字体的PostScript名称。下面是从字体册中获取“娃娃体-简 常规体”字体的PostScript名称的截图。 二、使用教程1.相关API介绍苹果提供了动态下载代码的Demo工程。将此Demo工程下载下来，可以学习相关API的使用。下面对该工程中相关API做简单的介绍。假如我们现在要下载“娃娃体”，他的PostScript名称为“DFWaWaSC-W5”。具体操作步骤如下。1.我们先判断该字体是否已经被下载下来，示例代码： 123456789//判断字体是否已经被下载- (BOOL)isFontDownloaded:(NSString *)fontName&#123; UIFont *aFont = [UIFont fontWithName:fontName size:12.]; if (aFont &amp;&amp; ([aFont.fontName compare:fontName] == NSOrderedSame || [aFont.familyName compare:fontName] == NSOrderedSame)) &#123; return YES; &#125;else&#123; return NO; &#125;&#125; 2.如果该字体已经下载过了，则可以直接使用。否则我们需要先准备下载字体API需要的一些参数，示例代码： 12345678//用字体的PostScript名字创建一个 dictionaryNSMutableDictionary *attrs = [NSMutableDictionary dictionaryWithObjectsAndKeys:fontName,kCTFontNameAttribute, nil];//创建一个字体描述对象 CTFontDescriptorRefCTFontDescriptorRef desc = CTFontDescriptorCreateWithAttributes((__bridge CFDictionaryRef)attrs);//将字体描述对象放到一个NSMutableArray中NSMutableArray *descs = [NSMutableArray arrayWithCapacity:0];[descs addObject:(__bridge id _Nonnull)desc];CFRelease(desc); 3.准备好上面的descs变量后，就可以进行字体的下载了，示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556__block BOOL errorDuringDownload = NO; //下载字体 CTFontDescriptorMatchFontDescriptorsWithProgressHandler((__bridge CFArrayRef)descs , NULL, ^bool(CTFontDescriptorMatchingState state, CFDictionaryRef _Nonnull progressParameter) &#123; double progressValue = [[(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingPercentage] doubleValue]; switch (state) &#123; case kCTFontDescriptorMatchingDidBegin: //字体已经匹配 break; case kCTFontDescriptorMatchingWillBeginDownloading: //字体开始下载 break; case kCTFontDescriptorMatchingDownloading: NSLog(@\" 下载进度 %.0f\",progressValue); break; case kCTFontDescriptorMatchingDidFinishDownloading: //字体下载完成 break; case kCTFontDescriptorMatchingDidFinish: &#123; //字体已经下载完成 if (!errorDuringDownload) &#123; NSLog(@\"字体%@ 已经下载完成\",fontName); dispatch_async( dispatch_get_main_queue(), ^ &#123; // 可以在这里修改 UI 控件的字体 _label.font = [UIFont fontWithName:_postName size:14]; return ; &#125;); &#125; &#125; break; case kCTFontDescriptorMatchingDidFailWithError: //下载错误 &#123; NSError *error = [(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingError]; if (error != nil) &#123; _errorMessage = [error description]; &#125; else &#123; _errorMessage = @\"ERROR MESSAGE IS NOT AVAILABLE!\"; &#125; // 设置标志 errorDuringDownload = YES; NSLog(@\" 下载错误: %@\", _errorMessage); &#125; break; default: break; &#125; return YES; &#125;); 通常需要在下载完字体后开始使用字体，一般是将相应的代码放到kCTFontDescriptorMatchingDidFinish 条件中，可以像苹果官方Demo那样，用GCD来修改UI逻辑，也可以发 Notification 来通知相应的Controller。程序运行截图： 本文参考《iOS开发进阶》– 唐巧本文demo下载地址","tags":[{"name":"UIFont","slug":"UIFont","permalink":"http://yoursite.com/tags/UIFont/"},{"name":"下载字体","slug":"下载字体","permalink":"http://yoursite.com/tags/下载字体/"}]},{"title":"iOS使用UIWindow","date":"2017-06-06T02:29:55.000Z","path":"2017/06/06/UIWindow/","text":"作者刘文涛转载请注明出处 UIWindow简介在iOS应用中，我们使用UIWindow和UIView来呈现界面。UIWindow是最顶层的界面容器。UIWindow并不包含任何默认的内容，但是它被当做UIView的容器，用于放置应用中的所有UIView。而每一个UIView通常都用来表示具体的某一部分界面，例如一段文字、一张图片等。当然你可以用UIView来当做其他UIView的容器。所以UIWindow更多的时候只是作为UIView的顶层容器存在。 NS_CLASS_AVAILABLE_IOS(2_0) @interface UIWindow : UIView 在继承关系上，我们能看到UIWindow继承自UIView，所以UIWindow除了具有UIView的功能外，还增加了一些特有的属性和方法。而我们最常用的方法就是在程序刚启动时，调用UIWindow的makeKeyAndVisible方法，使整个程序界面可见，代码如下所示： 123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; ViewController *vc = [[ViewController alloc] init]; vc.view.backgroundColor=[UIColor whiteColor]; self.window.rootViewController = vc; [self.window makeKeyAndVisible]; return YES;&#125; 所以UIWindow的主要作用有：1.做完UIView的最顶层容器，包含应用显示所需要的所有UIView。2.传递触摸消息和键盘事件给UIView。 为UIWindow增加UIView通常我们有两种方法给UIWindow增加子UIView：1.通过调用addSubView方法。因为UIWindow是UIView的子类，所以它可以使用UIView的addSubView方法给自己增加子VIew，从而承担容器的作用。2.通过设置其特有的rootViewController属性。通过设置该属性为要添加view对应的UIViewController，UIWindow将会自动将其view添加到当前window中，同时负责维护VIewController和view的生命周期。我们在之前的application: didFinishLaunchingWithOptions:示例代码中看到的就是这种方法。 系统对UIWindow的使用通常在一个程序中只会有一个UIWindow，但是有些时候我们调用系统的控件（例如UIAlertView）时，iOS系统为了保证UIAlertView在所有的界面之上，他会临时创建一个新的UIWindow，通过将其UIWindow的UIWindowLevel设置的更高，让UIAlertView盖在所有的应用界面之上。为了验证这一说法，我们创建了一个新的测试Xcode工程,在其主ViewController上添加一个button，点击button弹出一个系统的弹框。示例代码： 1234567- (IBAction)testButtonClicked:(UIButton *)sender &#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:@\"测试\" preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@\"取消\" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125; WindowLevel那么是不是新创建的UIWindow一定会在界面的最上层呢？其实不是这样的。UIWindow有一个WindowLevel的属性该属性定义了UIWindow的层级，系统定义的WindowLevel一共有三种取值： 123UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar __TVOS_PROHIBITED; 我们将这些值通过代码打印输出： 123NSLog(@\"UIWindowLevelNormal=%f\",UIWindowLevelNormal);NSLog(@\"UIWindowLevelAlert=%f\",UIWindowLevelAlert);NSLog(@\"UIWindowLevelStatusBar=%f\",UIWindowLevelStatusBar); 输出的结果： 2017-06-06 11:43:09.345 UIWindowDemo[899:667871] UIWindowLevelNormal=0.000000 2017-06-06 11:43:09.346 UIWindowDemo[899:667871] UIWindowLevelAlert=2000.000000 2017-06-06 11:43:09.346 UIWindowDemo[899:667871] UIWindowLevelStatusBar=1000.000000 从中我们可以看出来默认程序的UIWindow的层级是UIWindowLevelNormal，当系统需要在上面覆盖UIAlertView时，就会创建一个层级是UIWindowLevelAlert的UIWindow，因为其WindowLevel的值更高，所以就覆盖在上面了。在实际应用中，WindowLevel的取值并不限于上面提到的3个值。 手动创建UIWindow有些时候我们也希望在应用开发中，将某个界面覆盖在所有的界面最上层。这个时候我们就可以手动创建一个新的UIWindow。需要注意的是，和创建UIView不同，UIWindow一旦被创建，它就会自动被添加到整个界面上了。例如想做一个密码保护功能，在用户按home键退出应用界面，过一段时间后从后台切换回来时，显示一个密码输入界面。用户只有输入正确的密码才能进入退出的前台界面。因为这个密码输入界面可能从任何应用界面弹出，并且需要遮在所有界面的最上层，所以它很适合用UIWindow来实现。","tags":[{"name":"UIWindow","slug":"UIWindow","permalink":"http://yoursite.com/tags/UIWindow/"}]},{"title":"iOS开发-发送邮件及短信","date":"2017-06-01T08:22:20.000Z","path":"2017/06/01/mailAndMessage/","text":"作者刘文涛转载请注明出处 前言在iOS开发中，有时候我们会需要用到发送邮件及短信的功能。我们还可以通过发送邮件来接收用户反馈的崩溃通知等等。我用的是iOS原生自带的MFMailComposeViewController来实现的。他不会使程序进入后台，使用模态弹出邮件或短信发送界面。 代码示例1.发送邮件使用前需要导入框架：MessageUI.framework在使用的controller中导入头文件： #import &lt;MessageUI/MessageUI.h&gt;实现代理：&lt;MFMailComposeViewControllerDelegate,MFMessageComposeViewControllerDelegate&gt;获取用户是否设置了邮箱账户： 123456if ([MFMailComposeViewController canSendMail]) &#123; // 用户已设置邮件账户 [self sendEmailAction]; // 调用发送邮件的代码 &#125;else&#123; NSLog(@\"用户未设置邮箱账户\"); &#125; sendEmailAction方法代码： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)sendEmailAction&#123; // 邮件服务器 MFMailComposeViewController *mailCompose = [[MFMailComposeViewController alloc] init]; // 设置邮件代理 [mailCompose setMailComposeDelegate:self]; // 设置邮件主题 [mailCompose setSubject:@\"我是邮件主题\"]; // 设置收件人 [mailCompose setToRecipients:@[@\"邮箱号码\"]]; // 设置抄送人 [mailCompose setCcRecipients:@[@\"邮箱号码\"]]; // 设置密抄送 [mailCompose setBccRecipients:@[@\"邮箱号码\"]]; /** * 设置邮件的正文内容 */ NSString *emailContent = @\"邮件内容...\"; // 是否为HTML格式 [mailCompose setMessageBody:emailContent isHTML:NO]; // 如使用HTML格式，则为以下代码// [mailCompose setMessageBody:@\"&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\" isHTML:YES]; /** * 添加附件 */ UIImage *image = [UIImage imageNamed:@\"image\"]; NSData *imageData = UIImagePNGRepresentation(image); [mailCompose addAttachmentData:imageData mimeType:@\"\" fileName:@\"custom.png\"]; NSString *file = [[NSBundle mainBundle] pathForResource:@\"test\" ofType:@\"pdf\"]; NSData *pdf = [NSData dataWithContentsOfFile:file]; [mailCompose addAttachmentData:pdf mimeType:@\"\" fileName:@\"pdf文件\"]; // 弹出邮件发送视图 [self presentViewController:mailCompose animated:YES completion:nil];&#125; MFMailComposeViewControllerDelegate的代理方法： 12345678910111213141516171819202122 - (void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error&#123; switch (result) &#123; case MFMailComposeResultCancelled: NSLog(@\"取消发送\"); break; case MFMailComposeResultFailed: NSLog(@\"发送失败\"); break; case MFMailComposeResultSaved: NSLog(@\"保存草稿文件\"); break; case MFMailComposeResultSent: NSLog(@\"发送成功\"); break; default: break; &#125; // 关闭邮件发送视图 [self dismissViewControllerAnimated:YES completion:nil];&#125; 2.发送短信获取用户能否发送短信： 12345if ([MFMessageComposeViewController canSendText]) &#123; [self sendMessageAction];&#125;else&#123; NSLog(@\"用户不能发送短信\");&#125; sendMessageAction方法代码: 1234567891011121314// 调用系统API发送短信- (void)sendMessageAction&#123; MFMessageComposeViewController *messageVC = [[MFMessageComposeViewController alloc] init]; // 设置短信代理 messageVC.messageComposeDelegate = self; // 发送给谁 messageVC.recipients = @[@\"18701235678\"]; // 发送的内容 messageVC.body = @\"hello world\"; // 弹出发送短信的视图 [self presentViewController:messageVC animated:YES completion:nil];&#125; MFMessageComposeViewControllerDelegate的代理方法： 12345678910111213141516171819- (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result&#123; switch (result) &#123; case MessageComposeResultCancelled: NSLog(@\"取消发送\"); break; case MessageComposeResultFailed: NSLog(@\"发送失败\"); break; case MessageComposeResultSent: NSLog(@\"发送成功\"); break; default: break; &#125; [self dismissViewControllerAnimated:YES completion:nil]; &#125; 结语以上代码均在真机（iOS9）进行测试，并通过测试。注意发送邮件的时候需要你绑定邮箱账户。本文demo。","tags":[{"name":"MessageUI","slug":"MessageUI","permalink":"http://yoursite.com/tags/MessageUI/"}]},{"title":"iOS多线程编程 GCD介绍","date":"2017-05-19T06:52:46.000Z","path":"2017/05/19/GCDInfo/","text":"作者刘文涛转载请注明出处 一、简单介绍1.什么是GCDGrand Central Dispatch是由苹果开发的一个多核编程的解决方案。iOS4.0+才能使用，是替代NSThread， NSOperation的高效和强大的技术。苹果官方给出的解释：GCD是异步执行任务的技术之一。一般将应用程序中记述的线程管理代码在系统集中实现，开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就可以生成必要的线程并计划执行任务。GCD是基于C语言的。 2.GCD的优点它具有以下优点：1.GCD可以将花费时间及其长的任务放到后台线程，可以改善应用的响应性能。2.GCD提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。3.GCD具有在常见模式（例如单例）上用更高性能的底层语法优化你的代码的潜在能力等等。我创建一个并行队列queue，并异步执行耗时操作，当耗时操作执行完成后，我拿到其中的资源回到主线程来更新相应的UI，在这个block代码块之外，主线程并不会被耗时任务所堵塞，可以流畅的处理其他的事情。代码片段如下： 1234567891011121314151617dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); //用异步的方法执行任务 dispatch_async(queue, ^&#123; /** 放一些耗时的任务在此执行 */ dispatch_async(dispatch_get_main_queue(), ^&#123; /** 耗时的任务完成，拿到资源，回到主线程，更新UI 注意：更新UI只能在主线程中 */ &#125;); &#125;); 二、任务和队列GCD有两个核心的概念：1.任务：执行什么操作2.队列：用来存放任务GCD的使用步骤：1.定制任务2.确定想做的事情 将任务添加到队列中，GCD会自动将队列中的任务取出，放到相应的线程中去执行。提示：任务的取出遵循队列的FIFO（first in,first out）原则：先进先出，后进后出。 三、执行任务1.GCD中有2个用来执行任务的函数 说明：把右边的参数（任务）提交给左边的参数（队列）进行执行。 （1）用同步的方法执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 参数说明： queue：队列 block：任务 （2）用异步的方法执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 2.同步和异步的区别 同步：在当前线程中执行 异步：在另一条线程中执行 四、队列1.队列的类型GCD的队列可以分为2大类（1）并发队列 （ DISPATCH_QUEUE_CONCURRENT ） 可以让多个任务并发执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch——async）函数下才有效（2）串行队列 （ DISPATCH_QUEUE_SERIAL ） 让任务一个接一个的执行 （一个任务执行完毕后，在执行下一个任务） 2.补充说明同步和异步决定了要不要开启新的线程。同步：在当前线程中执行任务，不具备开启新线程的能力异步：在新的线程中执行任务，具备开启新线程的能力 并发和串行决定了任务的执行方式并发：多个任务同时执行串行：一个任务执行完毕后，在执行下一个任务 3.串行队列GCD中获得串行有两种途径（1）使用dispatch_queue_create函数创建串行队列 1dispatch_queue_t queue = dispatch_queue_create(&lt;#const char * _Nullable label#&gt;, &lt;#dispatch_queue_attr_t _Nullable attr#&gt;) //// 队列名称， 队列属性，一般用NULL即可 示例：1dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", NULL); （2）使用主队列主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务都会放到主线程中执行 使用dispatch_get_main_queue()获得主队列示例： 1dispatch_queue_t queue2 = dispatch_get_main_queue(); 4.并发队列GCD默认已经提供全局的并发队列，供整个应用使用，不需要手动创建使用dispatch_get_global_queue函数获得全局的并发队列示例： 1234567dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);说明：全局并发队列的优先级 #define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高 #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中） #define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低 #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台 5.各队列的执行效果 全局并发队列 手动创建串行队列 主队列 同步（sync） 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 异步（async) 开启新线程，并发执行任务 开启新线程，串行执行任务 没有开启新线程，串行执行任务 五、示例代码1.用异步函数往并发队列中添加任务示例： 1234567891011121314151617181920//1.获得全局的并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //2.添加任务到队列中，就可以执行任务 //异步函数：具备开启新线程的能力 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"主线程----%@\",[NSThread mainThread]); 输出：结论：在并发队列+异步执行中可以看出，除了主线程同时又开启了三个子线程，并且任务交替着同时执行。并且任务不是马上执行的，而是将所有的任务添加到队列之后才开始异步执行的。 2.用异步函数往串行队列中添加任务示例： 123456789101112131415161718192021222324252627//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1、创建串行队列 /** 第一个参数为串行队列的名称，是c语言的字符串 第二个参数为队列的属性，一般来说串行队列不需要赋值任何属性，所以通常传空值（NULL） */ dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", NULL); //2、添加任务到队列中执行 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：在串行队列+异步执行可以看到，只开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。并且是将所有任务添加到队列之后才开始同步执行。 3.用同步函数往并发队列中添加任务示例： 1234567891011121314151617181920212223//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：所有的任务都是在主线程中执行的，由于只有一个线程，所以任务只能一个一个执行，执行完一个任务，再执行下一个任务。并且并发队列是去了并发的功能。并且任务是添加到队列中马上执行的。 4.用同步函数往串行队列中添加任务示例： 1234567891011121314151617181920212223//打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_SERIAL); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); 输出：结论：所有的任务都是在主线程中执行的，并没有开启新的线程，并且按顺序一个一个执行。并且任务是添加到队列中马上执行的。 5.同步函数在主队列中执行示例： 12345678910111213141516171819202122232425- (void)syncMain&#123; //打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //获取主线程 dispatch_queue_t queue = dispatch_get_main_queue(); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;);&#125; 输出：这时候，我们发现在主线程中使用主队列+同步执行，任务不再执行了，这是为什么呢？这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主线程中他会立马执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个任务和第三个任务。那么现在的情况就是syncMain方法和第一的任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，我们的任务执行不了了。 不在主线程中调用，而在其他线程中调用1234dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [self syncMain]; &#125;); 123456789101112131415161718192021222324252627- (void)syncMain&#123; NSLog(@\"syncMain---begin\"); //打印主线程 NSLog(@\"主线程-----%@\",[NSThread mainThread]); //获取主线程 dispatch_queue_t queue = dispatch_get_main_queue(); //2.添加任务到队列中执行 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"syncMain---begin\");&#125; 输出：结论：所有的任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个的执行。同时我们还可以看到，所有的任务都是打印在syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。 6.异步函数在主队列中执行示例： 123456789101112131415161718192021222324- (void)asyncMain&#123; NSLog(@\"asyncMain---begin\"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"asyncMain---end\");&#125; 输出：结论：所有的任务都是在主线程中，虽然是异步执行，具备开启线程的能力，但是因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。另一方面可以看出，所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。 6.GCD的其他方法1.GCD的栅栏方法我们有时候需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。 123456789101112131415161718192021222324252627- (void)barrier&#123; dispatch_queue_t queue = dispatch_queue_create(\"liuwentao\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"1------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"2------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@\"barrier-----%@\",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"3------%@\",[NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 2; ++i) &#123; NSLog(@\"4------%@\",[NSThread currentThread]); &#125; &#125;);&#125; 输出：结论：可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后在执行栅栏后面的操作。 2.GCD的延时执行方法当我们需要延时执行一段代码时，就需要用到GCD的dispatch_after方法示例： 1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.9 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //2 秒后执行这里的代码 NSLog(@\"run-----\"); &#125;); 3.GCD只执行一次我们在创建单例或者整个程序运行过程中只执行一次的代码时，我们就用到了GCD的dispatch_once方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。示例： 1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //只执行1次的代码（这里面默认是线程安全的） &#125;); 4.GCD的快速迭代方法通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法dispatch_apply，使我们可以同时遍历。比如遍历0~5这6个数字，for循环是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。示例： 12345dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_apply(6, queue, ^(size_t index) &#123; NSLog(@\"%zd--------%@\",index,[NSThread currentThread]); &#125;); 输出：结论：从输出结果的时间可以看出，几乎是同时遍历出的。 5.GCD的队列组有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后在回到主线程执行操作。这时候我们可以用到GCD的队列组。我们可以先把任务放到队列中，然后将队列放入队列组中。调用队列组的dispatch_group_notify回到主线程执行操作。示例： 123456789101112//创建一个队列组 dispatch_group_t group = dispatch_group_create(); //添加任务到队列组中 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行1个耗时的异步操作 &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行1个耗时的异步操作 &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //等前面的异步操作都执行完毕后，回到主线程中... &#125;); 结语以上就是我对GCD的基础知识和几种组合的理解，如果觉得我有哪里理解的错误欢迎留下你的评论。","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"}]},{"title":"iOS多线程编程 NSOperation","date":"2017-05-11T02:28:31.000Z","path":"2017/05/11/NSOperation/","text":"作者刘文涛转载请注明出处 一、NSOperation1、简介NSOperation实例封装了需要执行的操作和执行操作所需的数据，并且能够以并发或非并发的方式执行这个操作。NSOperation本身是抽象基类，因此必须使用它的子类，使用NSOperation子类的方式有两种：1.Foundation框架提供了两个具体子类直接供我们使用：NSInvocationOperation和NSBlockOperation2.自定义子类继承NSOperation，实现内部相应的方法 2、执行操作NSOperation调用start方法即可开始执行操作，NSOperation对象默认按同步方式执行，也就是调用start方法的那个线程中直接执行。NSOperation对象的isConcurrent方法会告诉我们这个操作相对于调用start方法的线程，是同步还是异步执行。isConcurrent默认是返回NO,表示操作与调用线程同步执行 123NSOperation * operation = [[NSOperation alloc]init];//开始执行 [operation start]; 3、取消操作Operation开始执行之后，默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作 1[operation cancel]; 4、监听操作的执行如果我们想在一个NSOperation执行完毕后做一些事，就调用NSOperation的setCompletionBlock方法： 123[operation setCompletionBlock:^&#123; NSLog(@\"执行结束\");&#125;]; 二、NSInvocationOperation1.简介基于一个对象和selector来创建操作。如果你已经有现有的方法来执行需要的任务，就可以使用这个类 2.创建并执行操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 //调用self的run方法 NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //开始执行任务（同步执行） [operation start];```` ## 三、NSBlockOperation### 1.简介能够并发的执行一个或者多个block对象，所有相关的block都执行完之后，操作才算完成。### 2.创建并执行操作````objc NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"执行一个新的操作\"); &#125;]; //开始执行任务（同步执行） [operation start]; ```` ### 3.通过addExecutionBlock方法添加block操作````objc NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"执行一个新的操作\"); &#125;]; [operation addExecutionBlock:^&#123; NSLog(@\"添加1个新的操作\"); &#125;]; //开始执行任务（同步执行） [operation start];```` 这两个block是并发执行的，也就是在不同的线程中执行的## 四、自定义NSOperation### 1.简介如果NSInvocationOperation和NSBlockOperation对象不能满足需求, 你可以直接继承NSOperation, 并添加任何你想要的行为。继承所需的工作量主要取决于你要实现非并发还是并发的NSOperation。定义非并发的NSOperation要简单许多，只需要重载- (void)main这个方法，在这个方法里面执行主任务，并正确的响应取消事件；对于并发的NSOperation，你必须重新NSOperation的多个基本方法进行实现。### 2.非并发的NSOperation创建一个继承NSOperation的类：LWTNoCurrentOperation，重写main方法，在main方法中执行自定义的任务。LWTNoCurrentOperation.m````objc//自定义main方法执行你的任务- (void)main&#123; //在这里我们要创建自己的释放池，因为这里我们拿不到主线程的释放池 @autoreleasepool &#123; BOOL isDone = NO; //正确响应取消事件 while (![self isCancelled] &amp;&amp; !isDone) &#123; //在这里执行自己的任务操作 NSLog(@\"执行自定义非并发\"); NSThread *thread = [NSThread currentThread]; NSLog(@\"%@\",thread); //任务执行完后将isDone设为YES isDone = YES; &#125; &#125;&#125; 在ViewDidLoad中使用我们自定义的operation,并调用start方法。 12LWTNoCurrentOperation *operation = [[LWTNoCurrentOperation alloc] init]; [operation start]; 默认情况下，该OperaTion在当前调用start的线程中执行，其实如果我们创建多个自定义的LWTNoCurrentOperation，并放入NSOperationQueue中，这些任务也是并发执行的，只不过我们没有处理，线程执行完，KVO等操作。因此不建议在只实现main函数的情况下将其加入NSOperationQueue，只实现main一般只适合自定义非并发的NSOperation。 12345678910111213141516@property (nonatomic, strong) NSOperationQueue *myQueue;- (void)viewDidLoad &#123; [super viewDidLoad]; self.myQueue = [[NSOperationQueue alloc] init]; LWTNoCurrentOperation *operation1 = [[LWTNoCurrentOperation alloc] init]; [self.myQueue addOperation:operation1]; LWTNoCurrentOperation *operation2 = [[LWTNoCurrentOperation alloc] init]; [self.myQueue addOperation:operation2]; LWTNoCurrentOperation *operation3 = [[LWTNoCurrentOperation alloc] init]; [self.myQueue addOperation:operation3]; &#125; 3.并发的NSOperation","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"}]},{"title":"iOS多线程编程 NSThread介绍","date":"2017-05-10T01:35:33.000Z","path":"2017/05/10/NSThread/","text":"作者刘文涛转载请注明出处 一、简单介绍iOS支持多个层次的多线程编程，层次越高的抽象程度越高，使用也越方便，也是苹果最推荐的使用方法。下面根据抽象层次从低到高依次列出iOS所支持的多线程编程方法：1.Thread：是三种方法里相对轻量级的，但是需要管理线程的生命周期、同步、加锁问题，这会导致一定的性能开销；2.Cocoa Operations：是基于OC实现的，NSOperation以面向对象的方式封装了需要执行的操作，不必关心线程管理、同步等问题。NSOperation是一个抽象基类，iOS提供了两种默认实现：NSInvocationOperation和NSBlockOperation，当然也可以自定义NSOperation；3.Grand Central Dispatch（简称GCD，iOS4才开始支持的）：提供了一些新特性、运行库来支持多核并行编程，它的关注点更高：如何在多个CPU上提升效率； 这篇文章简单的介绍了第一种多线程的编程方式，主要利用NSThread这个类，一个NSThread实例代表着一条多线程。 二、NSthread的初始化1.动态方法- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0); 参数解析： target：selector消息发送的对象 selector：线程执行的方法，这个selector最多只能接收一个参数 argument：传给selector的唯一参数，也可以是nil 123456//初始化线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; //设置线程的优先级（0.0 -- 1.0 ,1.0是最高级） thread.threadPriority = 1.0; //开启线程 [thread start]; 2.静态方法+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 12[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];//调用完毕后，会马上创建并开启新的线程 3.隐式创建线程的方法[self performSelectorInBackground:@selector(run) withObject:nil]; 三、获取当前线程NSThread *current = [NSThread currentThread]; 四、获取主线程NSThread *mainThread = [NSThread mainThread]; 五、暂停当前线程//暂停2.0s [NSThread sleepForTimeInterval:2.0]; //或者 NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]]; [NSThread sleepUntilDate:date]; 六、线程间的通信1.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 2.在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 3.在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 七、优缺点优点：NSTread比其他两种多线程方案较轻量级，更直观的控制线程对象缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据加锁或有一定的系统开销。","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"NSThread","slug":"NSThread","permalink":"http://yoursite.com/tags/NSThread/"}]},{"title":"iOS开发masonry动态布局cell高度","date":"2017-04-15T07:39:36.000Z","path":"2017/04/15/masonryForCell/","text":"作者刘文涛转载请注明出处 前言说到iOS自动布局，有很多的解决办法。有的人使用xib/storyboard自动布局，也有人使用frame来适配。对于前者，笔者并不喜欢，也不支持。对于后者，更是麻烦，到处计算高度、宽度等，千万大量代码的冗余，对维护和开发的效率都很低。笔者在这里介绍纯代码自动布局的第三方库：Masonry。这个库使用率相当高，在全世界都有大量的开发者在使用，其star数量也是相当高的。本文Cell内容通过Masonry自动布局并且cell巧妙利用自动布局计算cell的动态高度。 正文实现思路：例如cell中有三个label，label1，label2，label3.1.为label1添加约束（以cell.cntentView为基准） 123456CGFloat one_W = SCREENWIDTH/2;[self.L1 makeConstraints:^*(MASConstraintMaker *make)&#123; make.left.mas_equalTo(16); make.top.mas_equalTo (10); make.width.mas_lessThanOrEqualTo(one_W);&#125;]; 2.为label2添加约束 使其在label1下方距离为5处 （以label1为基准）。 12345[self.L2makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(wself.L1.mas_left); make.top.equalTo(wself.L1.mas_bottom).offset(5); make.width.mas_lessThanOrEqualTo(one_W);&#125;]; 3.为label3添加约束 使其在label2 下方距离为5处 （以label2为基准，重点在于这个一定要在label3 添加一个距离cell。contentView底部的约束）。以上完成cell 子视图的约束。 123456[self.L3 makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(wself.L1.mas_left); make.top.equalTo(wself.L2.mas_bottom).offset(5); make.width.mas_lessThanOrEqualTo(SCREENWIDTH-32);make.bottom.equalTo(wself.contentView.mas_bottom).offset(-10);&#125;]; 4.在tableView heightForRowAtIndexPath 代理中使用一个单独的不显示在屏幕的cell 作为计算cell高度使用，通过下面代码获取cell高度： 1234567891011customCell *cell= [customCellshareInstance]; //返回cell之前重新刷新约束，重新计算高度 [cell setNeedsUpdateConstraints]; [cell updateConstraintsIfNeeded]; [cell setCellContent:self.data[indexPath.row]]; [cell setNeedsLayout]; [cell layoutIfNeeded]; CGFloat height = [cell.contentViewsystemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; return height; 本文demo","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"masonry","slug":"masonry","permalink":"http://yoursite.com/tags/masonry/"},{"name":"动态布局","slug":"动态布局","permalink":"http://yoursite.com/tags/动态布局/"}]},{"title":"如何使UIWebview/WKWebView支持WebP格式图片","date":"2017-04-13T05:43:26.000Z","path":"2017/04/13/webp-image-format-ios/","text":"作者Talent•C转载自Talent•C 前言在一般的app中占用流量最大的内容一般都是图片,以苹果公司 Retina 产品为代表的高 PPI 屏对图片的质量提出了更高的要求，如何保证在图片的精细度不降低的前提下缩小图片体积，成为了一个有价值且值得探索的事情。但如今对于 JPEG、PNG 和 GIF 这些图片格式的优化几乎已经达到了极致， 若想改变现状开辟新局面，便要有釜底抽薪的胆量和气魄，而 Google 给了我们一个新选择：WebP。 正文WebP是什么? WebP（发音 weppy，来自:Google WebP），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。在 Google 的明星产品如 Youtube、Gmail、Google Play 中都可以看到 WebP 的身影，而 Chrome 网上商店甚至已完全使用了 WebP。国外公司如 Facebook、ebay 和国内公司如腾讯、淘宝、美团等也早已尝鲜。下面是QQ图片格式对比图 iOS中如何使用WebP格式图片?很幸运,SDWebImage支持WebP格式图片,可以讲WebP数据–&gt;NSData–&gt;UIImage There are 3 subspecs available now: Core, MapKit and WebP (this means you can install only some of the SDWebImage modules. By default, you get just Core, so if you need WebP, you need to specify it).Podfile example:$pod ‘SDWebImage/WebP’摘自SDWebImage 我们需要手动下载WebP这个库,由于是从Google下载的,如果下载失败,请翻墙重试!!!下载后的文件路径 Xcode 需要如下配置 targets-&gt;build settings -&gt;preprocessor Macros 填写 SD_WEBP=1 如图到此app 中支持 WebP图片基本完成,但是重点来了,由于部分app使用到了UIWebview/WKWebview 这两个控件是不支持WebP图片的,目前有两种方式可以让其支持WebP格式图片。 实现方式一 NSURLProtocol对于NSURLProtocol的作用及使用以后找个时间再讲了~~~~可以参考Apple 开发者文档NSURLProtocol, UIWebView 直接就可以支持,但是WKWebView是不支持的,如何让WKWebView也支持NSURLProtocol可以参考这篇文章,不过WKWebView自定义NSURLProtocol会丢失boay数据。文章结尾会附上Demo下载地址。 WKWebView 拓展支持NSURLProtocol 具体代码如下12345678910111213141516171819202122232425262728293031323334FOUNDATION_STATIC_INLINE Class ContextControllerClass() &#123; static Class cls; if (!cls) &#123; cls = [[[WKWebView new] valueForKey:@\"browsingContextController\"] class]; &#125; return cls;&#125;FOUNDATION_STATIC_INLINE SEL RegisterSchemeSelector() &#123; return NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");&#125;FOUNDATION_STATIC_INLINE SEL UnregisterSchemeSelector() &#123; return NSSelectorFromString(@\"unregisterSchemeForCustomProtocol:\");&#125;@implementation NSURLProtocol (WebKitExt)+ (void)wk_registerScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = RegisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125;+ (void)wk_unregisterScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = UnregisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125; 好了,现在UIWebView与WKWebView 都已经支持自定义NSURLProtocol了;我们创建一个类CLURLProtocol 继承自NSURLProtocol下面这几个方法必须实现 +(BOOL)canInitWithRequest:(NSURLRequest )request;+(NSURLRequest )canonicalRequestForRequest:(NSURLRequest *)request;-(void)stopLoading;-(void)startLoading; 这里不过多废话了 直接上代码123456789101112131415161718192021222324+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; /** 判断是否启用SD_WEBP 并且图片格式为webp 如果为YES 则标记请求需要自行处理并且防止无限循环 为NO则不处理 */ BOOL useCustomUrlProtocol = NO; NSString *urlString = request.URL.absoluteString; if (!SD_WEBP || ([urlString.pathExtension compare:@\"webp\"] != NSOrderedSame)) &#123; useCustomUrlProtocol = NO; &#125;else &#123; //防止无限循环 if ([NSURLProtocol propertyForKey:CLProtocolKey inRequest:request] == nil) &#123; useCustomUrlProtocol = YES; &#125;else &#123; useCustomUrlProtocol = NO; &#125; &#125; return useCustomUrlProtocol;&#125;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; return request;&#125;- (void)stopLoading&#123; //将截获的请求使用NSURLConnection | NSURLSession 获取数据 这里使用的是NSURLConnection&#125; 我们在创建一个WebV继承自UIViewController 用来展示webView12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; self.automaticallyAdjustsScrollViewInsets = NO; if ([self.webView isKindOfClass:[WKWebView class]]) &#123; //WKWebView 注册自定义 NSURLProtocol [NSURLProtocol registerClass:NSClassFromString(@\"CLURLProtocol\")]; [NSURLProtocol wk_registerScheme:@\"http\"]; [NSURLProtocol wk_registerScheme:@\"https\"]; //发起请求 WKWebView *web = (WKWebView *)self.webView; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://onzbjws3p.bkt.clouddn.com/testForwebpSrc/testWebpForHtml.html\"]]]; &#125;else if ([self.webView isKindOfClass:[UIWebView class]]) &#123; //UIWebView 注册自定义 NSURLProtocol [NSURLProtocol registerClass:NSClassFromString(@\"CLURLProtocol\")]; //发起请求 UIWebView *web = (UIWebView *)self.webView; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://onzbjws3p.bkt.clouddn.com/testForwebpSrc/testWebpForHtml.html\"]]]; &#125; &#125;//因为NSURLProtocol 一旦被注册将会使整个app的request请求都会被拦截 我们这里只在进入WebVC时向系统注册,退出WebVC时取消注册 具体时机请自行决定- (void)dealloc&#123; NSLog(@\"WebVC -- dealloc\"); if ([self.webView isKindOfClass:[WKWebView class]]) &#123; [NSURLProtocol unregisterClass:NSClassFromString(@\"CLURLProtocol\")]; [NSURLProtocol wk_unregisterScheme:@\"http\"]; [NSURLProtocol wk_unregisterScheme:@\"https\"]; &#125;else if ([self.webView isKindOfClass:[UIWebView class]]) &#123; [NSURLProtocol unregisterClass:NSClassFromString(@\"CLURLProtocol\")]; &#125;&#125; 到此为止UIWebView/WKWebView 均已支持加载webp格式图片效果如图WKWebView 展示效果 UIWebView 展示效果 UIImageView 展示效果 优点: 适合所有网页,可以不用修改网页内部html内容。 缺点: NSURLProtocol 拦截App 的所有请求, 使用时需要根据个人项目情况而定, WKWebView 在post请求时会丢失boay, 目前解决方式为在WKWebView的 开始加载的 代理方法判断是否为post,为post解除注册自定义的NSURLProtocol,为GET请求时注册自定义NSURLProtocol。 实现方式二 通过JavaScript与OC共同完成实现思路:1、向网页内注入JS2、在App 本地开启线程下载图片,下载完成后,将图片转码由 webP—&gt; png—&gt;Base64。3、将 Base64及原图片下载地址一一对应调用JS准备好的方法进行替换。4、将下载后的图片进行缓存,并进行管理。 注意注意:A、图片未真正加载完毕时,网页中图片为了体验好可以添加默认占位图片。B、图片显示成功前应该保持网页布局不调整,需要由JS预先设置好布局。C、图片在本地的缓存需要管理。 获取网页img标签的js代码123456789101112function talentcGetAllImageSrc ()&#123; var imagesList = document.images; var srcList = []; var patt1 = new RegExp(\"\\.webp$\"); for(var i = 0; i &lt; imagesList.length; i++) &#123; if(patt1.test(imagesList[i].src)) &#123; srcList.push(imagesList[i].src); &#125; &#125; return JSON.stringify(srcList);&#125;; 替换网页img标签的js代码1234567function talentcReplaceWebPImg (src, localPath)&#123; var elementList = document.querySelectorAll('img[src=\"'+src+'\"]'); for(var element in elementList) &#123; elementList[element].src = localPath; &#125;&#125; 优点:对于UIWebview 与 WKWebView是通用不需要特殊处理,也不会拦截App中的请求。 缺点:对于展示的第三方网页需要根据网页做一些适配, 例如部分网页展示图片使用的div的background-image。 UIWebView 展示效果 WKWebView 展示效果全文终 本文demo 下载","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"WebView","slug":"WebView","permalink":"http://yoursite.com/tags/WebView/"},{"name":"WebP","slug":"WebP","permalink":"http://yoursite.com/tags/WebP/"}]},{"title":"UIlabel设置行间距,字间距","date":"2017-04-10T06:49:21.000Z","path":"2017/04/10/labelSetAttribute/","text":"在iOS开发中经常会用到UIlabel来展示一些文字性的内容，但是默认的文字排版会觉得有些挤，为了更美观也更易于阅读我们可以通过某些方法将UIlabel的行间距和字间距按照需要调节。代码如下： 12345678910111213141516- (void)setLabelSpace:(UILabel *)label withValue:(NSString *)str withFont:(UIFont *)font&#123; NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init]; paraStyle.lineBreakMode = NSLineBreakByCharWrapping; paraStyle.alignment = NSTextAlignmentLeft; paraStyle.lineSpacing = UILABEL_LINE_SPACE; //设置行间距 paraStyle.hyphenationFactor = 1.0; paraStyle.firstLineHeadIndent = 0.0; paraStyle.paragraphSpacingBefore = 0.0; paraStyle.headIndent = 0; paraStyle.tailIndent = 0; //设置字间距 NSKernAttributeName:@1.5f NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.5f&#125;; NSAttributedString *attributeStr = [[NSAttributedString alloc] initWithString:str attributes:dic]; label.attributedText = attributeStr;&#125; 1234567891011121314151617//计算UILabel的高度（带有行间距的情况）-(CGFloat)getSpaceLabelHeight:(NSString*)str withFont:(UIFont*)font withWidth:(CGFloat)width &#123; NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init]; paraStyle.lineBreakMode = NSLineBreakByCharWrapping; paraStyle.alignment = NSTextAlignmentLeft; paraStyle.lineSpacing = UILABEL_LINE_SPACE; paraStyle.hyphenationFactor = 1.0; paraStyle.firstLineHeadIndent = 0.0; paraStyle.paragraphSpacingBefore = 0.0; paraStyle.headIndent = 0; paraStyle.tailIndent = 0; NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.5f&#125;; CGSize size = [str boundingRectWithSize:CGSizeMake(width, HEIGHT) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size; return size.height;&#125;","tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"},{"name":"UILabel","slug":"UILabel","permalink":"http://yoursite.com/tags/UILabel/"}]}]